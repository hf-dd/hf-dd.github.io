<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HF Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-06T05:24:42.059Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>innodb 与 myisam 区别</title>
    <link href="http://yoursite.com/2020/02/06/innodb%20%E4%B8%8E%20myisam%20%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/06/innodb%20%E4%B8%8E%20myisam%20%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-06T05:23:38.000Z</published>
    <updated>2020-02-06T05:24:42.059Z</updated>
    
    <summary type="html">
    
      两种数据库引擎的区别
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>innodb 与 myisam 区别</title>
    <link href="http://yoursite.com/2020/02/06/%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/06/%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-06T05:23:38.000Z</published>
    <updated>2020-02-06T05:32:08.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h4><p>1.InnoDB 支持事务，MyISAM 不支持，对于 InnoDB 每一条 SQL 语言都默认封装成事务， 自动提交，这样会影响速度，所以最好把多条 SQL 语言放在 开启事务begin transaction 和 提交commit之间，组成一个事务； </p><p>2.InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为MYISAM会失败；</p><p>3.InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引 效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此， 主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 </p><p>4.InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><p>5.Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>1.看是否支持事务，支持就选择 innodb，如果不需要可以考虑 MyISAM</p><p>2.如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使 用 InnoDB。 </p><p>3.系统崩溃，MyISAM 恢复起来更困难</p><p>4.MySQL5.5 版本开始 Innodb 已经成为 Mysql 的默认引擎(之前是 MyISAM)，说明其优势 是有目共睹的，如果你不知道用什么，那就用 InnoDB，至少不会差。</p>]]></content>
    
    <summary type="html">
    
      两种数据库引擎的区别
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面经知识点概述总结！</title>
    <link href="http://yoursite.com/2020/02/05/%E9%9D%A2%E7%BB%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/02/05/%E9%9D%A2%E7%BB%8F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-05T13:24:05.000Z</published>
    <updated>2020-02-06T05:18:15.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong>LRU：双向链表+hashMap</strong><br>save(key, value)，在 HashMap 找到 Key 对应的节点，如果节点存在，把这个节点移动队头。如果不存在，需要构造新的节点，并且尝试把节点塞到队头，如果LRU空间不足，则通过 tail 淘汰掉队尾的节点，同时在 HashMap 中移除 Key。get(key)，通过 HashMap 找到 LRU 链表节点，把节点放入表头</p><p><strong>逃逸分析（并不成熟</strong>）：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。<br>同步省略：同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么对对象的加的锁JIT编译阶段就会被优化掉（锁消除）<br>标量替换：在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替<br>栈上分配：经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</p><p><strong>分布式锁：</strong><br>基于数据库（唯一索引）：唯一索引天然具有排他性，同一时刻只能允许一个竞争者获取锁<br>基于缓存：利用Redis的setnx key value这个命令，只有当key不存在时才会执行成功，如果key已经存在则命令执行失败。<br>基于Zookeeper：我们在Zookeeper中创建瞬时节点，利用节点不能重复创建的特性来保证排他性。</p><p>操作系统：内核、驱动程序、接口库、外围<br>Linux系统一般有4个主要部分:内核、shell、文件系统和应用程序。</p><p><strong>内存泄露</strong>：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。典型例子：<br>1 Vector v = new Vector(10);    //最简单的方法就是将 Vector 对象设置为 null。<br>2 for (int i = 1; i &lt; 100; i++) {<br>3     Object o = new Object();<br>4     v.add(o);      //循环申请Object对象，并将所申请的对象放入一个 Vector 中<br>5     o = null;  //仅仅释放引用本身，那么 Vector 仍然引用该对象，gc不可回收<br>6 }</p><p><strong>Redis为什么单线程还那么快</strong>：1.纯内存访问，Redis将所有数据放在内存中<br>2.非阻塞I/O,Redis使用I/O多路复用技术，以让单个线程高效的处理多个连接请求                                          3.单线程避免了线程切换和竞争产生的消耗</p><p><strong>多路I/O复用模型</strong>是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是指轮询那些真正发出了事件的流），并且指依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>为什么zset用快表不用红黑树</strong>（查询单个数据时间复杂度一样但是如下）：<br>1.在做范围查找的时候，平衡树比skiplist操作要复杂。<br>2.平衡树的插入和删除操作会引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br>3.跳表的实现相较于红黑树更加简洁。</p><p><strong>MySql为什么用 b+ 不用 b 数</strong>：<br>因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少<br>指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</p><p><strong>一条SQL语句执行的很慢原因</strong>：先分成俩种情况<br>偶尔很慢：1.数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘，此时其他操作需要等待<br>2.执行的时候，遇到锁，如表锁、行锁。<br>一直很慢：1.没有用上索引，例如该字段没有索引或者对索引字段进行运算、函数操作导致无法用索引。<br>2.数据库选错了索引，由于统计的失误，导致系统没有走索引，而是走了全表扫描</p><p><strong>TCP粘包是什么</strong>:    TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾</p><p><strong>造成粘包原因：</strong>发送方，TCP默认使用Nagle算法   1.只有上一个分组得到确认，才会发送下一个分组          2.收集多个小分组，在一个确认到来时一起发送                                                                                                              接受方，TCP接收到数据包时，应用层并不会立即处理。会先放入缓存，再等应用程序去读取。</p><p><strong>TCP如何保证数据的顺序化传输</strong>：1.为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>2.并为每个已发送的数据包启动一个超时定时器；<br>3.如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>4.否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>5.接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><p><strong>索引为什么能加快查询效率</strong>：索引通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。</p><p><strong>AQS</strong>就是基于双向队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列尾部，等待被唤醒。AQS是自旋锁：在等待唤醒的时候，经常会使用自旋的方式，不停地尝试获取锁，直到被其他线程获取成功</p><p>现在，在处理<strong>高并发计数</strong>时，应该优先使用<strong>LongAdder</strong>，而不是继续使用<strong>AtomicLong</strong>。原因：LongAdder是根据ConcurrentHashMap基本原理——锁分段，来实现的，不同的线程可以在不同的计数单元上进行计数，这样减少了线程竞争，提高了并发效率，本质上是用空间换时间的思想。</p>]]></content>
    
    <summary type="html">
    
      针对一些常考知识，简答总结到一起，面试前必看
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java对象的组成部分</title>
    <link href="http://yoursite.com/2020/02/05/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
    <id>http://yoursite.com/2020/02/05/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</id>
    <published>2020-02-05T05:28:38.000Z</published>
    <updated>2020-02-06T05:07:07.675Z</updated>
    
    <content type="html"><![CDATA[<p>对象谁都知道，但对象里面到底有什么，却很少有人去了解，今天我们就来看看对象到底由哪些部分组成</p><p>简单来说：Java对象保存在内存中时，由以下三部分组成：<strong>对象头</strong>，<strong>实例数据</strong>，<strong>对齐填充字节</strong></p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头由三部分组成：<strong>Mark Word</strong>，<strong>指向类的指针</strong>，<strong>数组长度</strong>（只有数组对象才有）</p><p><strong>Mark Word</strong>记录了对象和锁有关的信息。</p><p>1.对象没有被当成锁时，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</p><p>2.当对象被当做同步锁并有一个<strong>线程A</strong>抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，表示进入偏向锁状态</p><p>3.<strong>线程A</strong>再来试图来获得锁时，锁标志位还是01，并发现自己已经得到了偏向锁，所以可以执行同步锁的代码。</p><p>4.当<strong>线程B</strong>试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</p><p>5.偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为<strong>轻量级锁</strong>。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6</p><p>6.轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7。</p><p>7.自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p><p><strong>指向类的指针</strong></p><p>该指针在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p><p>Java对象的类数据保存在方法区。<strong>通过该指针确定该对象是哪个类的实例</strong></p><p><strong>数组长度</strong></p><p>只有数组对象保存了这部分数据。</p><p>该数据在32位和64位JVM中长度都是32bit。</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>对象的实例数据就是在java代码中能看到的属性和他们的值。</p><h4 id="对齐填充字节"><a href="#对齐填充字节" class="headerlink" title="对齐填充字节"></a>对齐填充字节</h4><p>因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。</p><p>原文链接：<a href="https://blog.csdn.net/lkforce/article/details/81128115" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/81128115</a></p>]]></content>
    
    <summary type="html">
    
      对象头和对象组成详解
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>基于lucene的elasticsearch</title>
    <link href="http://yoursite.com/2020/02/03/%E5%9F%BA%E4%BA%8Elucene%E7%9A%84elasticsearch/"/>
    <id>http://yoursite.com/2020/02/03/%E5%9F%BA%E4%BA%8Elucene%E7%9A%84elasticsearch/</id>
    <published>2020-02-03T06:16:00.000Z</published>
    <updated>2020-02-06T04:58:54.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lucene"><a href="#lucene" class="headerlink" title="lucene"></a>lucene</h3><p>首先，elasticsearch（简称ES）是基于lucene的，lucene是什么？lucene 是最先进、功能最强大的搜索库，其实就是一个jar包，包含了封装好的各种建立倒排索引的算法代码，如果直接基于 lucene 开发，非常复杂，所以我们一般直接就调用lucene 的 api 去开发就可以了。</p><p><strong>搜索引擎原理</strong>：爬取内容，进行分词，建立反向索引也叫倒排索引。</p><p><strong>倒排索引</strong>是什么？传统正向索引，在文章中找词，而倒排索引是从关键词出发，找到对应的文章。</p><p>倒排底层实现基于FST,优点空间占用小，对单词前缀和后缀重复利用，查询快。</p><p><strong>Elasticsearch</strong></p><p>而elasticsearch 就是基于 lucene，隐藏了 lucene 的复杂性，提供了简单易用的 restful api 接口，是一个存储海量数据的分布式搜索引擎。</p><p>为什么要有ES，因为模糊查询会放弃索引，会导致全表扫描，大数据量下效率低，而我们可以把经常查询的字段放入ES中，可以提高查询速度。</p><p><strong>基本结构</strong>：</p><p>索引（index）:类似一个数据库，可以是商品索引，每个索引里可以有一个或者多个 type。</p><p>类型（type）：类似数据的一个表。可以是家用商品类型，电器商品类型，一个type包含多条document，用mapping定义type表结构类型例如哪些字段，字段是哪些类型。</p><p>文档（document）：类中表的一条数据，es 中最小的数据单元,可以是一条商品数据、一条订单数据，通常用 json 数据结构来表示。每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p><p><strong>分布式原理</strong>：</p><p>Elasticsearch 会对数据进行切分(shard)，同时每一个分片会保存多个副本(replica ),为了保证分布式环境下的高可用。</p><p>并且同样基于maste-slave架构，在 Elasticsearch 中，节点是对等的，节点间会通过自己的一些规则选取集群的 Master，Master 会负责集群状态信息的改变，并同步给其他节点。</p><p>注意，只有建立索引和类型需要经过 Master，数据的写入有一个简单的 Routing 规则，可以 Route 到集群中的任意节点，所以数据写入压力是分散在整个集群的。</p><p> Elasticsearch 搭建 ELK 系统，也就是日志分析系统。其中 E 就是 Elasticsearch，L 是 Logstash，是一个日志收集系统，K 是 Kibana，是一个数据可视化平台。</p><p>keyword和text字段区别：keyword直接建立反向索引，text先分词再建立反向索引</p><p><strong>面试题</strong></p><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是<strong>随机轮询算法</strong>。</p><p><strong>搜索过程</strong>：客户端发送请求到一个协调节点，协调节点将搜索请求转发到所有的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>，每个 shard 将<strong>文档的ID和排序值</strong>返回给协调节点，然后协调节点根据这些ID去各个节点拉取document 数据返回给客户端。</p><p>如何实现master选举：1.确认候选主节点数达标         2.比较：先判定是否具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则id小的值会主节点。</p><p>性能优化：1.es 的搜索引擎严重依赖于底层的 <strong>filesystem cache</strong>，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。            2.<strong>数据预热</strong>，每隔一段时间，就访问一下，让数据进入 filesystem cache 里面去。               3.<strong>冷热分离</strong>，将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引</p>]]></content>
    
    <summary type="html">
    
      elasticsearch到底是怎么样的搜索啊
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Get和Post的区别</title>
    <link href="http://yoursite.com/2020/02/02/Get%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/02/02/Get%E5%92%8CPost%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-02T12:54:35.000Z</published>
    <updated>2020-02-06T04:59:04.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>不同：</strong></p><p>1.get参数通过URL传递，post放在Request body中，所以相对来说get更加安全。</p><p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制，可发送更多数据</p><p>2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</p><p>3.get后退不会有影响，post后退会重新进行提交</p><p>4.get产生一个TCP数据包（header和data一起发送），post产生两个TCP数据包（先发送header，再发送data）。也就是get请求一次，post俩次（不是都俩次，火狐听说就一次）。get效率高，post传输慢。</p><p>5.get请求可以被缓存，post不可以被缓存</p><p>6.get请求只URL编码，post支持多种编码方式</p><p>7.get只支持ASCII字符，post没有字符类型限制</p><p>8.get请求参数会留在历史记录中，post请求不会留在历史记录</p><p><strong>相同：</strong></p><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p><p> HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p>]]></content>
    
    <summary type="html">
    
      get和post,问出来必须知道的几个点
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MD5！！</title>
    <link href="http://yoursite.com/2020/02/02/MD5%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/02/02/MD5%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</id>
    <published>2020-02-02T05:23:56.000Z</published>
    <updated>2020-02-02T05:50:54.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>今天写简历的时候回想起自己所写项目的难点，突然想起了MD5加密，当初的难点虽然非常多，但是这个尤为记忆深刻！现在还记得，当初找到了一个MD5加密工具类，然后给自己的密码加了密，数据库中的密码就变成了类似b8c37e33defde51cf91e1e03e51657da这样的东西。当时就觉的很厉害也没注意，没想到更厉害的还在后面，我不小心把密码忘了，再登录已经登不上去，没办法只能去改数据库的密码了，没想到改了还是登不上去，这就叫我很纳闷了，还能这样的，今天就来看看他为什么。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先，MD5 是摘要算法而不是加密算法，属于Hash算法一代，是一种单向加密算法，可以将输入的信息加密转换为128位固定长度的散列值，用于检验数据传输过程中的完整性。一般配合加盐来使用。</p><p><strong>摘要算法</strong>是单向的，即明文可以通过摘要算法生成摘要结果，但反之则不能通过摘要结果还原成明文（<strong>意思就是不可逆，不能解密</strong>）。</p><p>而<strong>加密算法</strong>是双向的，即可以从明文通过加密算法生成密文，反之也可以通过解密算法将密文还原成明文。</p><p>加密算法，可以分可逆加密，不可逆加密，可逆加密又分为对称加密与非对称加密（RSA公钥加密算法，公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用。）</p><p><strong>摘要算法主要用来检查明文是否发生过变动，而加密算法则用来传递不能让第三方知晓的内容。</strong></p>]]></content>
    
    <summary type="html">
    
      MD5都听说过，如何大致理解它，今天就来说说
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis和mysql的数据一致性</title>
    <link href="http://yoursite.com/2020/02/01/Redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2020/02/01/Redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2020-02-01T15:05:20.000Z</published>
    <updated>2020-02-01T16:00:17.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用Redis缓冲读数据的流程为："><a href="#利用Redis缓冲读数据的流程为：" class="headerlink" title="利用Redis缓冲读数据的流程为："></a><strong>利用Redis缓冲读数据的流程为：</strong></h3><p>开始读，判断缓冲中是否有数据，有则返回给客户端，没有的话就会去数据库中查询，如果还没有就返回没有，如果有的话就会写入缓冲中，再返回客户端。</p><p>一般业务操作都是该流程，读的话可以看出不会出现太大问题，但如果有数据的更新呢？那么就会产生一些问题了。</p><h3 id="可能会出现的问题："><a href="#可能会出现的问题：" class="headerlink" title="可能会出现的问题："></a><strong>可能会出现的问题：</strong></h3><p>更新数据的时候，先更新数据库，然后要删除缓存旧的数据，但是没有删除成功，此时数据库和缓存的数据就发生了不一致。</p><p>改进：要求先删除缓存数据成功后，再更新数据库，这样保证数据一致性。</p><p>但还是会有问题：删除缓存数据成功后，更新数据库的操作还没执行完的时候，另一个线程就来读数据，此时缓存为空，去数据库查找，此时数据库的数据还是没更新前的，读取到然后传给缓存。这时候数据库成功更新了数据，接下来就知道了，数据库和缓存的数据不一致了。</p><h3 id="那么到底如何解决一致性问题呢？"><a href="#那么到底如何解决一致性问题呢？" class="headerlink" title="那么到底如何解决一致性问题呢？"></a><strong>那么到底如何解决一致性问题呢？</strong></h3><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。我们接下来考虑的都不是设置过期时间的方法。</p><p><strong>1.采用延时双删策略</strong></p><p>先删除缓存，再写数据库，休眠500毫秒，再次删除缓存。这样可以确保另一个线程读请求结束，写请求可以删除读请求造成的缓存脏数据（就是上述问题）。休眠时间看自己情况。</p><p><strong>2.异步更新缓存(基于订阅binlog的同步机制)</strong></p><p>binlog二进制日志文件，记录所有增删改的SQL语句，不记录查的语句，因为没有对数据进行修改。</p><p>这样，一旦数据库数据发生更新，就把binlog推给Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>MySQL的主从备份机制也是利用binlog来实现数据一致性，binlog记录推送给Redis的方式可以采用常见的消息队列就行。</p>]]></content>
    
    <summary type="html">
    
      读数据从Redis缓存，那么如何保证Redis和mysql数据是一致的呢。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git常用的命令！</title>
    <link href="http://yoursite.com/2020/02/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%81/"/>
    <id>http://yoursite.com/2020/02/01/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%81/</id>
    <published>2020-02-01T14:53:27.000Z</published>
    <updated>2020-02-03T14:44:05.121Z</updated>
    
    <content type="html"><![CDATA[<p><strong>git add</strong></p><p>git add 是把要传的数据添加到一个仓库或者说是暂存区，意思就是先放在里面，告诉它们我们将要对这些数据进行操作了。</p><p><strong>git commit</strong></p><p>而git commit就是进行操作的第一步，就是将本地修改过的文件提交到<strong>本地库</strong>中。</p><p><strong>git push</strong></p><p>第二步就是git push，将本地库中的最新信息发送给<strong>远程库</strong>，供其他人可见。</p><p><strong>git fetch</strong></p><p>只能更新远程仓库的代码为最新的，本地仓库的代码还未被更新,通常和<strong>git merge</strong> 合并结合来用</p><p><strong>git pull</strong></p><p>将本地仓库和远程仓库都更新到远程的最新版本，相当于git fetch+git merge</p><p>git pull的问题是它把过程的细节都隐藏了起来,出问题很难找到，<strong>可控一点的话推荐使用fetch + merge</strong></p>]]></content>
    
    <summary type="html">
    
      Git的add,push,commit
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BIO,NIO,AIO</title>
    <link href="http://yoursite.com/2020/01/31/BIO-NIO-AIO/"/>
    <id>http://yoursite.com/2020/01/31/BIO-NIO-AIO/</id>
    <published>2020-01-31T05:50:18.000Z</published>
    <updated>2020-01-31T07:15:47.928Z</updated>
    
    <content type="html"><![CDATA[<p>1.同步：使用同步IO时，Java自己处理IO读写。</p><p>2.异步：使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS，完成后OS通知Java处理（回调）。</p><p>3.阻塞：使用阻塞IO时，Java调用会一直阻塞到读写完成才返回。</p><p>4.非阻塞：使用非阻塞IO时，如果不能立马读写，Java调用会马上返回，当IO事件分发器通知可读写时在进行读写，不断循环直到读写完成。</p><p>下面是重点了（敲黑板！）！</p><p>1.BIO：<strong>同步并阻塞</strong>，服务器的实现模式是<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，可能造成不必要的线程开销，当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。</p><p>2.NIO：在JDK1.4以前，Java的IO模型一直是BIO，但从JDK1.4开始，JDK引入的新的IO模型NIO，它是<strong>同步非阻塞</strong>的。而服务器的实现模式是<strong>多个请求一个线程</strong>，即请求会注册到多路复用器Selector上，<strong>多路复用器</strong>轮询到连接有IO请求时才启动一个线程处理。    </p><p>3.AIO：JDK1.7发布了NIO2.0，这就是真正意义上的<strong>异步非阻塞</strong>，服务器的实现模式为<strong>多个有效请求一个线程</strong>，客户端的IO请求<strong>都是由OS先完成再通知</strong>服务器应用去启动线程处理（回调）。</p><p>应用场景：并发连接数不多时采用BIO，因为它编程和调试都非常简单，但如果涉及到高并发的情况，应选择NIO（连接数目多且连接比较短）或AIO（连接数目多且连接比较长），更好的建议是采用成熟的网络通信框架Netty。</p>]]></content>
    
    <summary type="html">
    
      Java中BIO、NIO和AIO的区别和应用场景
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>事务以及分布式事务！</title>
    <link href="http://yoursite.com/2020/01/30/%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/30/%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%81/</id>
    <published>2020-01-30T03:27:02.000Z</published>
    <updated>2020-01-30T04:55:16.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务提供一种“要么什么都不做，要么都做”的机制，她有ACID四大特性：</p><p>原子性（A）：一个事务是一个不可分割的工作单位，要么都做，要么都不做。</p><p>一致性（C）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致状态是指数据库中的数据应满足完整性约束。</p><p>隔离性（I）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p><p>持久性（D）：已被提交的事务对数据库的修改应该永久性的。</p><p><strong>单机事务</strong>：事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><strong>XA协议</strong>包含<strong>两阶段提交（2PC）</strong>和<strong>三阶段提交（3PC）</strong>两种实现。</p><p><strong>两阶段提交（2PC）</strong>：包含俩个角色<strong>事务协调者</strong>TM和<strong>事务参与者</strong>AP。</p><p><strong>第一阶段</strong>：事务协调者首先向所有的事务参与者发送Prepare请求。每个参与者执行相关事务操作Undo Log和Redo Log，如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。得到了所有参与者成功消息后，进入第二阶段。</p><p><strong>第二阶段</strong>：因为前面都是成功消息，事务协调者会向所有事务参与者发送Commit请求，接到请求后事务参与者各自会进行事务提交，释放锁，然后返回协调者“完成”消息。整个流程完成。</p><p><strong>出错流程</strong>：第一阶段如果都发送Prepare请求后，有一个或多个参与者返回了错误消息，必须进行回滚，所以第二阶段事务协调者会向所有参与者发送Abort请求，之后所有参与者进行回滚，回滚操作依照Undo Log来进行。</p><p>缺点：<strong>1.性能问题</strong>，只有所有节点都准备好，事务才能提交，很明显性能很差。<strong>2.协调者单点故障问题</strong>，事务协调者一宕机，基本就全完了。<strong>3.丢失消息导致的不一致问题</strong>，不同事务参与者因为消息的丢失，导致节点数据不一样了。</p><p><strong>解决方法：</strong></p><p><strong>XA三阶段提交</strong>：在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。有效解决了协调者单点故障的问题，协调者挂掉，其他参与者超时得不到消息会自行本地commit。</p><p><strong>MQ事务</strong>：引入了消息中间件（助理），负责消息的传递和事务执行状态的询问。这样就降低了系统间的耦合度，解决了性能问题。</p><p><strong>TCC事务</strong>：TCC指的是Try(尝试)、Confirm（确认）、Cancle（取消）,其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。跟两阶段提交（2PC）比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些。</p><p><strong>拓展：</strong></p><p>CAP定理</p><p>CAP原则又称CAP定理，指的是在一个分布式系统中，WEB服务无法同时满足以下3个特性：</p><pre><code>一致性(Consistency) ： 在分布式系统中数据一旦更新，所有数据变动都是同步的可用性(Availability) ： 好的响应性能，每个操作都必须有预期的响应结束分区容错性(Partition tolerance) ： 在网络分区的情况下，即使出现单个节点无法可用，系统依然正常对外提供服务</code></pre><p>首先在分布式系统中，横向扩展策略依赖于数据分区，所以一般会在一致性和可用性上做出牺牲。</p>]]></content>
    
    <summary type="html">
    
      面试高频的事务，必须总结一番
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>进程的通信方式?</title>
    <link href="http://yoursite.com/2020/01/27/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/27/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2020-01-27T13:09:36.000Z</published>
    <updated>2020-01-31T13:28:45.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h3><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。</p><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><h3 id="IPC通信方式"><a href="#IPC通信方式" class="headerlink" title="IPC通信方式"></a>IPC通信方式</h3><p>管道（无名管道，高级管道，命名管道），消息队列，信号量机制，共享内存，套接字。</p><p><strong>无名管道（匿名管道）pipe：</strong>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系兄弟进程关系。</p><p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。基于字节流</p><p>例如父进程数据流入子进程，关闭父进程的读端 fd[0] 与子进程的写端 fd[1]，让数据从父进程写端流入子进程读端，反之同理。</p><p><strong>高级管道（popen）：</strong>将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p><strong>命名管道（FIFO）：</strong>FIFO也是半双工的通信方式，允许无亲缘关系进程间的通信。FIFO有路径名与之相关联，是一种文件类型。</p><p><strong>消息队列：</strong>消息的链接表，存放在内核中。一个消息队列由一个标识符（即<strong>队列ID</strong>）来标识。可以直接在进程间传送消息，较高级，可被多线程所共享，面向记录（数据特定格式），可实现随机查询，不一定要按先进先出次序读取。</p><p><strong>信号量机制：</strong>信号量加一减一，简单PV操作，实现同步和互斥，操作系统都讲过。</p><p><strong>共享内存：</strong>指两个或多个进程共享一个给定的存储区。共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式（因为直接对内存进行存取），它是针对其他进程间通信方式运行效率低而专门设计的。因为多个进程可以同时操作，所以需要进行同步，通常信号量+共享内存结合在一起使用。</p><p><strong>套接字：</strong>它和别的通信方式最主要不同的是可用于不同机器间的进程通信。</p>]]></content>
    
    <summary type="html">
    
      进程间通信IPC的几种方式？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM的垃圾回收机制！</title>
    <link href="http://yoursite.com/2020/01/25/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/25/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%81/</id>
    <published>2020-01-25T13:48:11.000Z</published>
    <updated>2020-01-29T03:44:23.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类加载器子系统"><a href="#1-类加载器子系统" class="headerlink" title="1.类加载器子系统"></a>1.类加载器子系统</h3><p>Java的动态类加载功能是由类加载器子系统处理。采用的是双亲委派机制（加载类先交给上层父类加载）</p><p>启动类加载器 (BootStrap class Loader)：启动时初始加载一些包，<strong>rt.jar</strong>，根加载器，拥有最高权限。</p><p>扩展类加载器(Extension class Loader)：加载扩展功能的一些jar包。</p><p>应用程序类加载器(System ClassLoader)：加载class path下的所有类。</p><h3 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2.运行时数据区"></a>2.运行时数据区</h3><p>方法区（Method Area）：所有类，静态变量，静态方法，成员方法，常量，共享（线程不安全）。</p><p>堆区（Heap Area）：所有对象和他的实例new出来的，数组，共享（不安全）。</p><p>栈区（Stack Area）：局部变量，对象的引用，每个线程创建（安全）。</p><p>程序计数器：（唯一一个不抛出OOM）保存当前线程执行的内存地址。安全</p><p>本地方法栈：为JVM使用到的native方法服务。</p><h3 id="3-GC（垃圾回收）"><a href="#3-GC（垃圾回收）" class="headerlink" title="3.GC（垃圾回收）"></a>3.GC（垃圾回收）</h3><p>GC的作用：  排查内存溢出，排查内存泄漏，性能调优，排查并发瓶颈</p><p>GC做了什么：哪些内存需要回收？什么时候回收？如何回收？</p><h4 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h4><p>回收已经”死“的内存，哪些已”死“？</p><p>对象没有引用，作用域发生未捕获异常，程序在作用域正常执行完毕，程序执行了System.exit()，程序发生意外终止（被杀进程等）</p><p><strong>判断已死方法</strong>：最早的引用计数法，引用一个对象时，计数器加一，引用失效，减一。为0时判断已死，有弊端，无法解决循环引用问题，所有java不使用该方法。而采用的方法为<strong>可达性分析算法</strong>，从根节点GC ROOT开始，向下寻找它的引用节点，没有找到的节点就是无用可回收节点。</p><p>可作为GC Roots的对象包含以下几种：</p><ol><li>虚拟机栈中引用的对象。</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中(Native方法)引用的对象</li></ol><h4 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h4><p>引用的分类：强引用（只要强引用在，永远不回收），软引用（内存够，就不回收，不够就回收了），弱引用（不管内存够不够都回收），虚引用（每次都回收）。</p><p><strong>可达性分析算法</strong>后标记的无用节点，并不是直接回收，会再进行一次筛选判断有必要执行finalize()，没有则死，有则得到一次最后逃脱死亡的机会。</p><p><strong>类被回收的条件</strong>：该类的所有实例都已经被回收(即在Java堆中不存在任何该类的实例)，加载该类的ClassLoader已被回收，该类对应的Class对象没有任何其他地方被引用，无法在任何地方通过反射访问该类的方法。</p><h4 id="如何回收？"><a href="#如何回收？" class="headerlink" title="如何回收？"></a>如何回收？</h4><p><strong>标记-清除算法</strong>：先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>缺点：效率低，会产生内存碎片。</p><p><strong>复制算法</strong>：将内存分成大小相同俩块，每次只用一块。第一块回收完，将活着的对象放到另外一块，第一块彻底清理，下次一样。效率高，不会产生内存碎片。</p><p><strong>标记-整理算法</strong>：在标记-清除算法的基础上，回收后将存活对象都推到左端空闲区域，解决内存碎片问题。</p><p><strong>JVM的优化：</strong>采用分代回收方式。</p><p>新生代内存的回收（minor GC）主要采用复制算法，新生代分成三部分，Eden,  Survivor  From，Survivor To=8:1:1。 将Eden和From区存活对象，放入To区，清空前面俩区，下次就是Eden和To到From，Survivor内存不够时，存入老年代。</p><p>老年代内存回收（Full GC，Major GC）主要采用标记-整理算法。</p><p>区别：新生代，每次有大量对象产生，大量对象被回收，次数频繁，因此采用效率高，速度快的复制算法。</p><p>老年代，对象存活率高，没有额外空间对它进行分配，采用标记-整理算法，次数少，Major GC的速度一般会比Minor GC慢10倍以上。</p><p><strong>JVM垃圾回收器</strong>：串行（Serial），并行（Parallel,ParNew），并发（CMS）</p><p>Serial收集器：JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止.</p><p>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</p><p>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld.</p><p> ParNew收集器：多CPU模式下的首选回收器，也是Server模式下的默认收集器。</p><p>ParallelScavenge收集器：又被称为是吞吐量优先的收集器。    </p><p>ParallelOld收集器：是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。</p><p><strong>CMS</strong>：又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法。</p><p>过程为：初始标记，并发标记，重新标记，并发清除。</p><p>优点：并发收集、低停顿。</p><p>缺点：CMS收集器对CPU资源非常敏感，占CPU资源，且总吞吐量下降，基于标志-清除算法，会产生碎片。</p>]]></content>
    
    <summary type="html">
    
      深入理解JVM的垃圾回收机制GC！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TCP是如何保证传输可靠性的？</title>
    <link href="http://yoursite.com/2020/01/23/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/01/23/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F/</id>
    <published>2020-01-23T13:20:27.000Z</published>
    <updated>2020-01-23T15:36:09.383Z</updated>
    
    <content type="html"><![CDATA[<p>首先，要弄懂TCP是如何保证传输可靠的，就必须知道TCP的特点是什么，大家可以根据我的另一篇博客（TCP和UDP的区别）一起结合来看，更加容易明白。</p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>20个字节包括源端口和目的端口，序号，确认号，数据偏移 <em>，</em>保留 ，窗口，检验和等等。</p><h4 id="保证方式："><a href="#保证方式：" class="headerlink" title="保证方式："></a>保证方式：</h4><p><strong>检验和</strong>：将发送数据都当做16位整数，相加，进位补在后面，最后取反。</p><p>发送与接收方都要进行检验和操作，不一致则代表数据传输有误，一致就表示数据不一定传输成功。</p><p><strong>确认号和序号</strong>：TCP三次握手建立连接，我们知道TCP传输每个字节都加了序号，每次接收方接收数据也都会返回发送方一个ACK报文，即确认报文，序号也可以排序，这些都可以保证传输可靠性。</p><p><strong>超时重传机制</strong>：发送数据后，迟迟等不到ACK确认报文，就开始重传机制也就是重新发送一遍。等不到ACK有俩种可能。一种是发送数据的时候就丢失了，接收方根本就没看见，另外一种是接收方收到数据了，发送了ACK报文但是丢失了或者超时，发送方接不到。</p><p><strong>流量控制：</strong>（针对点对点）我们知道TCP会根据接收窗口的窗口值来决定发送数据的大小，会进行拆分。所谓流量控制就是让发送方发送数据慢一些，不要让接收方压力太大，一口气接收不过来导致数据丢失。使用的方式就是滑动窗口！</p><p><strong>拥塞控制：</strong>（针对全局）防止过多的数据注入到网络中，这样可以使网络中的路由器或链路过载。解决方式：慢开始，拥塞避免，快重传，快恢复。</p>]]></content>
    
    <summary type="html">
    
      讲解TCP可靠传输是如何得到保障的
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>分布式-集群模式-微服务</title>
    <link href="http://yoursite.com/2020/01/22/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/01/22/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-01-22T07:53:23.000Z</published>
    <updated>2020-01-30T05:04:50.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>将一个大的系统划分为多个业务模块，业务模块分别部署到不同的机器上，各个业务模块之间通过接口进行数据交互，区别分布式的方式是根据不同机器不同业务。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡。一般配置Nginx的负载容器实现。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p> 微服务是一种面向服务的<strong>架构(SOA)风格</strong>，是很小的服务（松耦合），小到一个服务只对应一个单一的功能，只做一件事。这个服务可以单独部署运行，服务之间可以通过远程调用RPC（SpringCloud、Dubbo、Dubbox、Hessian、HttpClient、thrift等）来相互交互。说通俗点，就是将一个很小的方法写好，封装起来，专门让不同的人去调用。</p><p>微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。</p>]]></content>
    
    <summary type="html">
    
      分布式-集群模式-微服务的概念以及区分
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocl</title>
    <link href="http://yoursite.com/2020/01/21/ThreadLocl%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/21/ThreadLocl%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%81/</id>
    <published>2020-01-21T12:42:15.000Z</published>
    <updated>2020-01-21T13:09:10.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>用与之密切相关的俩个类来讲述ThreadLocal的工作原理：</p><p>分别是ThreadLocalMap，Thread。</p><p>其中ThreadLocalMap类的定义是在ThreadLocal类中，真正的引用却是在Thread类中。</p><p>ThreadLocalMap中用于存储数据的entry定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           /** The value associated with this ThreadLocal. */</span><br><span class="line">           Object value;</span><br><span class="line">           </span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现Map的key是ThreadLocal类的实例对象，value为用户的值。</p><p>所以根据上面可知，线程共享变量缓存如下：</p><p>线程共享变量缓存如下：</p><p><strong>Thread.ThreadLocalMap&lt;ThreadLocal, Object&gt;</strong></p><p>1、<strong>Thread: 当前线程，可以通过Thread.currentThread()获取。</strong></p><p>2、<strong>ThreadLocal：ThreadLocal实例对象。</strong></p><p>3、<strong>Object: 当前线程共享变量。</strong></p><p>ThreadLocal.get，ThreadLocal.set，ThreadLocal.remove方法都是从当前线程中获取ThreadLocalMap&lt;<strong>ThreadLocal, Object</strong>&gt;，然后获取或设置共享变量Object。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>每个线程独自拥有一个变量，并非是共享的（<strong>提供线程内的局部变量，这种变量在线程的生命周期内起作用</strong>）</p><p>final修饰的int型的threadLocalHashCode用来区分一个线程多个ThreadLocal对象</p><h3 id="内存泄漏问题（弱引用）："><a href="#内存泄漏问题（弱引用）：" class="headerlink" title="内存泄漏问题（弱引用）："></a>内存泄漏问题（弱引用）：</h3><p>当线程没有结束，但是ThreadLocal已经被回收，则可能导致线程中存在ThreadLocalMap&lt;<strong>null</strong>, <strong>Object</strong>&gt;的键值对，造成内存泄露。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量。</p><p>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</p>]]></content>
    
    <summary type="html">
    
      理解ThreadLocl的工作原理
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sleep,和Wait!</title>
    <link href="http://yoursite.com/2020/01/19/Sleep%E5%92%8CWait/"/>
    <id>http://yoursite.com/2020/01/19/Sleep%E5%92%8CWait/</id>
    <published>2020-01-19T12:32:31.000Z</published>
    <updated>2020-01-30T12:47:15.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>继承自Thread类，无释放锁，会给低优先级线程运行的机会，必须捕获异常，让当前线程休眠指定时间，也可由interrupt()方法来唤醒，静态方法，任何地方可以使用，执行sleep()方法后转入阻塞状态。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h3><p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会，无需捕获异常，执行yield()方法后转入就绪状态。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>继承自Object类，释放了锁（使得其他线程可以使用同步控制块或者方法），无需捕获异常，由notify,notifyAll方法唤醒，实例方法，只能在同步控制方法或者同步控制块里面使用。</p><h3 id="为什么wait只能在同步控制方法或者同步控制块里面使用？"><a href="#为什么wait只能在同步控制方法或者同步控制块里面使用？" class="headerlink" title="为什么wait只能在同步控制方法或者同步控制块里面使用？"></a>为什么wait只能在同步控制方法或者同步控制块里面使用？</h3><p>wait()暂停的是持有锁的对象，所以想调用wait()必须为:对象.wait();</p><p>因为要对持有锁的线程操作，所以要使用在同步中，因为只有同步才具有锁。</p><p><strong>锁可以是任意对象，所以任意对象调用的方法一定是定义在Object类中</strong></p>]]></content>
    
    <summary type="html">
    
      Sleep和Wait的区别，简显易懂
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nosql</title>
    <link href="http://yoursite.com/2020/01/19/redis%E5%92%8CMongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2020/01/19/redis%E5%92%8CMongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-01-19T02:25:01.000Z</published>
    <updated>2020-01-19T03:06:51.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB:"></a>MongoDB:</h2><p>概念：文档型数据库,类似json格式,它在许多场景下可用于<strong>替代</strong>统的关系型数据库或键/值存储方式。</p><p>特点：有权限验证类似RBAC，本身就是持久化数据库。</p><p>使用场景：主要解决海量数据的访问效率问题。比如网站的评论海量数据。</p><p>优点：</p><p>1.可处理大规模单表，容易分隔表。</p><p>2.非常高的插入速度。</p><p>3.高查询，支持二维空间索引，例如管道，快速定位。</p><p>缺点：</p><p>1.不支持事务（主要）</p><p>2.占用空间大</p><p>3.没有成熟维护工具</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><p>概念：开源的可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>特点：有权限验证，不过是全局的。Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。</p><p>使用场景：适用于对读写效率要求都很高，数据变化快等。例如：网站的点赞，计算，实时数据</p><p>支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><p>优点：</p><p>1.支持事务</p><p>2.数据存在内存，读写非常快</p><p>缺点：</p><p>由于 Redis 是内存数据库,所以,单台机器,存储的数据量,跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略,但是还是需要提前预估和节约内存</p><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase:"></a>HBase:</h2><p>概念：是 Apache Hadoop 中的一个子项目，实现语言java,HBase 依托于 Hadoop 的 HDFS（分布式文件系统）作为最基本存储基础单元。</p><p>特点：支持数十亿行X上百万列，不会出现单点故障，堪比MySQL的随机访问性能。</p><p>使用场景：</p><p>1.bigtable类型的数据存储</p><p>2.bigtable类型的数据存储</p><p>3.bigtable类型的数据存储</p><p>优点：</p><p>1.存储容量大，一个表可以容纳上亿行，上百万列</p><p>2.通过版本检索</p><p>3.可有效避免单点故障</p><p>缺点:</p><p>1.其API更适用于Java项目</p><p>2.占用空间大,依赖多，配置麻烦</p>]]></content>
    
    <summary type="html">
    
      NoSql型Redis和MongoDB和HBase的区别，优劣，使用场景
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别？</title>
    <link href="http://yoursite.com/2019/12/21/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/12/21/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2019-12-21T07:06:44.000Z</published>
    <updated>2020-01-22T05:56:07.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>1.TCP是<strong>面向连接</strong>的运输层协议。传送数据前需用三次握手方式进行连接，传送完毕后，必须释放已经建立的TCP连接。</p><p>2.TCP连接只能有俩个<strong>端点</strong>，即只能一对一，点对点。</p><p>3.TCP提供<strong>可靠支付</strong>的服务，无差错，不丢失，不重复，按序到达。</p><p>4.TCP提供<strong>全双工通信</strong>（通信双方都可作为传送者，接收者，且可以同时传输接收）</p><p>5.TCP面向<strong>字节流</strong>，流是指的是流入到进程或从进程流出的字节序列。</p><p>6.TCP不关心应用程序一次把多长的报文发送到TCP的缓存，而是根据对方给出的<strong>窗口值</strong>和当前<strong>网络拥塞</strong>的程度来决定一个报文段应包含多少个字节</p><p>7.首部20个字节（源端口和目的端口，序号，确认号，数据偏移 <em>，</em>保留 ）。</p><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>1.UDP是<strong>无连接</strong>的协议，传输数据前不需要建立连接，减小了开销和时延。</p><p>2.UDP连接支持一对一，一对多，多对一，多对多的交互通信。</p><p>3.UDP使用尽最大努力支付，即<strong>不可靠支付</strong>。</p><p>4.UDP<strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。</p><p>5.UDP<strong>面向报文</strong>，应用层交给UDP多长的报文，UDP就照样发送，既不合并，也不拆分，即一次发送一个报文</p><p>6.UDP发送的报文长度是应用进程给出的。</p><p>7.首部8个字节。</p>]]></content>
    
    <summary type="html">
    
      TCP和UDP哪里不同，具体表现在哪里？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网关、路由、DNS、子网掩码、MAC地址的概念</title>
    <link href="http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2019-12-10T03:42:17.000Z</published>
    <updated>2019-12-10T04:17:17.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是网关"><a href="#1-什么是网关" class="headerlink" title="1.什么是网关"></a>1.什么是网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p><p>按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。</p><p>那么网关到底是什么呢？网关实质上是一个<strong>网络</strong>通向<strong>其他网络</strong>的<strong>IP地址</strong>。</p><h3 id="2-ip地址又是什么"><a href="#2-ip地址又是什么" class="headerlink" title="2.ip地址又是什么"></a>2.ip地址又是什么</h3><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽<strong>物理地址</strong>的差异。</p><p>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用”点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如，192.168.1.1</p><p>常见的IP地址，分为IPv4与IPv6两大类。目前还有些ip代理软件，但大部分都收费。IPV4就是有4段数字，每一段最大不超过255。</p><h3 id="3-什么是物理地址"><a href="#3-什么是物理地址" class="headerlink" title="3.什么是物理地址"></a>3.什么是物理地址</h3><p>物理地址也就是我们常说的<strong>MAC地址</strong>，MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>mac地址位于OSI七层网络协议的第二层—<strong>数据链路层</strong>。通常表示为12个16进制数，每2个16进制数之间用冒号隔开，例如08:00:20:0A:8C:6D</p><h4 id="ip和mac区别"><a href="#ip和mac区别" class="headerlink" title="ip和mac区别"></a>ip和mac区别</h4><p>1.IP地址是服务商给你的，mac地址是你的网卡物理地址；</p><p>2.IP地址局域网内可以随便更改，但是mac地址一般不能更改；</p><p>3.长度不同。IP地址为32位，MAC地址为48位；</p><p>4.IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</p><p>5.总的来说，IP地址在网络中体现的是“<strong>我在哪里</strong>”，而mac地址则在二层通信中体现<strong>“我是谁”</strong></p><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h3><p>路由器是互联网络中必不可少的网络设备之一，路由器是一种连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。</p><p>在<strong>没有路由器</strong>的情况下，不同的两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过<strong>网关</strong>。</p><h3 id="5-什么是DHS"><a href="#5-什么是DHS" class="headerlink" title="5.什么是DHS"></a><strong>5.什么是DHS</strong></h3><p>DNS：域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>浏览器输入URL，例如<a href="http://www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。" target="_blank" rel="noopener">www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。</a></p><h3 id="6-子网掩码"><a href="#6-子网掩码" class="headerlink" title="6.子网掩码"></a>6.子网掩码</h3><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h4><p> 有一个网段是192.168.1.0—–192.168.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p><p>另外有一个网段，是192.168.0.0——192.168.255.254，我们叫它<strong>安村</strong>，村里有个同样有两个ip地址192.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？<br> 这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是<strong>255.255.255.0</strong>，<strong>安村</strong>的网段是<strong>255.255.0.0</strong>。</p><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p><p>强烈推荐一篇用故事讲解什么是网关，路由，dns的关系的文章，写的很好，大家可以看看奥</p><p>原文出处：<a href="https://blog.csdn.net/sgl520lxl/article/details/51974215" target="_blank" rel="noopener">https://blog.csdn.net/sgl520lxl/article/details/51974215</a></p>]]></content>
    
    <summary type="html">
    
      这篇主要讲述了几个关于计算机网络常见名词的解析
    
    </summary>
    
    
    
  </entry>
  
</feed>
