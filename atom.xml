<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HF Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-10T04:17:17.271Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网关、路由、DNS、子网掩码、MAC地址的概念</title>
    <link href="http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2019-12-10T03:42:17.000Z</published>
    <updated>2019-12-10T04:17:17.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是网关"><a href="#1-什么是网关" class="headerlink" title="1.什么是网关"></a>1.什么是网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p><p>按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。</p><p>那么网关到底是什么呢？网关实质上是一个<strong>网络</strong>通向<strong>其他网络</strong>的<strong>IP地址</strong>。</p><h3 id="2-ip地址又是什么"><a href="#2-ip地址又是什么" class="headerlink" title="2.ip地址又是什么"></a>2.ip地址又是什么</h3><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽<strong>物理地址</strong>的差异。</p><p>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用”点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如，192.168.1.1</p><p>常见的IP地址，分为IPv4与IPv6两大类。目前还有些ip代理软件，但大部分都收费。IPV4就是有4段数字，每一段最大不超过255。</p><h3 id="3-什么是物理地址"><a href="#3-什么是物理地址" class="headerlink" title="3.什么是物理地址"></a>3.什么是物理地址</h3><p>物理地址也就是我们常说的<strong>MAC地址</strong>，MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>mac地址位于OSI七层网络协议的第二层—<strong>数据链路层</strong>。通常表示为12个16进制数，每2个16进制数之间用冒号隔开，例如08:00:20:0A:8C:6D</p><h4 id="ip和mac区别"><a href="#ip和mac区别" class="headerlink" title="ip和mac区别"></a>ip和mac区别</h4><p>1.IP地址是服务商给你的，mac地址是你的网卡物理地址；</p><p>2.IP地址局域网内可以随便更改，但是mac地址一般不能更改；</p><p>3.长度不同。IP地址为32位，MAC地址为48位；</p><p>4.IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</p><p>5.总的来说，IP地址在网络中体现的是“<strong>我在哪里</strong>”，而mac地址则在二层通信中体现<strong>“我是谁”</strong></p><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h3><p>路由器是互联网络中必不可少的网络设备之一，路由器是一种连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。</p><p>在<strong>没有路由器</strong>的情况下，不同的两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过<strong>网关</strong>。</p><h3 id="5-什么是DHS"><a href="#5-什么是DHS" class="headerlink" title="5.什么是DHS"></a><strong>5.什么是DHS</strong></h3><p>DNS：域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>浏览器输入URL，例如<a href="http://www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。" target="_blank" rel="noopener">www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。</a></p><h3 id="6-子网掩码"><a href="#6-子网掩码" class="headerlink" title="6.子网掩码"></a>6.子网掩码</h3><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h4><p> 有一个网段是192.168.1.0—–192.168.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p><p>另外有一个网段，是192.168.0.0——192.168.255.254，我们叫它<strong>安村</strong>，村里有个同样有两个ip地址192.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？<br> 这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是<strong>255.255.255.0</strong>，<strong>安村</strong>的网段是<strong>255.255.0.0</strong>。</p><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p><p>强烈推荐一篇用故事讲解什么是网关，路由，dns的关系的文章，写的很好，大家可以看看奥</p><p>原文出处：<a href="https://blog.csdn.net/sgl520lxl/article/details/51974215" target="_blank" rel="noopener">https://blog.csdn.net/sgl520lxl/article/details/51974215</a></p>]]></content>
    
    <summary type="html">
    
      这篇主要讲述了几个关于计算机网络常见名词的解析
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>输入一个URL全过程！</title>
    <link href="http://yoursite.com/2019/12/08/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/"/>
    <id>http://yoursite.com/2019/12/08/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/</id>
    <published>2019-12-08T06:16:59.000Z</published>
    <updated>2019-12-08T06:33:50.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简单理解:</strong>  域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt;  服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）  –&gt; 浏览器对页面进行渲染呈现给用户。</p><p><strong>（1）域名解析（利用DNS），其实就是根据用户输入的网址去寻找它对应的IP地址，比如输入<a href="http://www.baidu.com它的ip地址为202.108.22.5" target="_blank" rel="noopener">www.baidu.com它的ip地址为202.108.22.5</a></strong></p><p>一般会先去各种缓冲中查找，浏览器缓存，Hosts文件查找，路由器缓存，DNS缓存，都找不到就由DNS解析查找</p><p><strong>（2）建立TCP连接</strong> </p><p><strong>客户端发起请求：</strong></p><ol><li><p><strong>应用层</strong></p><p>DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输。</p></li><li><p><strong>传输层</strong>，这里也就使用了<strong>TCP三次握手</strong></p><p>TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)，HTTP会话会被分成报文段，添加源、目的端口（默认80）；TCP协议进行主要工作。</p></li><li><p><strong>网络层</strong>是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址</p></li><li><p>然后才是<strong>链路层</strong>将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束</p></li></ol><p><strong>服务端接受请求：</strong><br>原路进行处理：链路层—&gt;网络层—&gt;传输层—&gt;应用层然后响应客户端发送报文。</p><p><strong>（3）浏览器进行处理</strong></p><p>服务器通过后台语言程序处理,找到数据返回给浏览器,HTML字符串被浏览器接受后被一句句读取解析,解析到link标签后重新发送请求获取css,解析到sript标签后发送请求获取js,并执行代码</p><p><strong>（4）绘制网页</strong></p><p>然后浏览器会进行渲染，浏览器根据HTML和CSS计算得到渲染树,绘制到屏幕上,js会被执行</p>]]></content>
    
    <summary type="html">
    
      输入一个URL返回了一个页面的全过程解析！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK,JRE,JVM的关系</title>
    <link href="http://yoursite.com/2019/12/07/JDK-JRE-JVM%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/12/07/JDK-JRE-JVM%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2019-12-07T05:58:49.000Z</published>
    <updated>2019-12-07T06:07:04.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>JDK（Java Development Kit）</strong></p><p>Java开发工具包，Java标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。</p><p><strong>Java Runtime Environment（JRE）</strong></p><p>Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><p><strong>JVM（java virtual machine）</strong></p><p>就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><p>也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><h3 id="2-联系"><a href="#2-联系" class="headerlink" title="2.联系"></a>2.联系</h3><p>JDK是面向开发者的，JRE是面向使用JAVA程序的用户</p><p>JDK包括了Java运行环境JRE、Java工具和Java基础类库</p><p>JRE包含了JVM标准实现及Java核心类库。</p><p>JVM 是 java 编程语言的核心并且具有平台独立性。</p><p>JDK&gt;JRE&gt;JVM</p>]]></content>
    
    <summary type="html">
    
      JDK,JRE,JVM出现频率不可谓不多，那到底是什么，就让我们来看看
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>时间复杂度常见讲解</title>
    <link href="http://yoursite.com/2019/12/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E8%A7%81%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E8%A7%81%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-12-04T05:59:02.000Z</published>
    <updated>2019-12-04T06:27:44.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话），<strong>冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域。</strong></p><p>例子：比如你面前有十个盒子，分别标着1-10号数字，你要找哪个数字直接就可以看到找出，不用一个一个都看一遍。那如果是N个盒子呢？同理，直接找你要的数字就可以了，所以耗时永远不变，为1.</p><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。</p><p>例子：遍历算法，要找到一个数组里面最大的一个数，你需要把n个变量都扫描一遍，操作次数为n，那么算法复杂度就是O(n).</p><h2 id="O（n-2）"><a href="#O（n-2）" class="headerlink" title="O（n^2）"></a>O（n^2）</h2><p>时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比O(n)更高的时间复杂度</p><p>例子：冒泡排序，双重循环，用冒泡排序排一个数组，对于n个变量的数组，需要交换变量位置O(n^2)次，那么算法复杂度就是O(n^2)。</p><h2 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h2><p>O(log n)，当数据增大n倍时，耗时增大log n倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比O(n)还要低的时间复杂度）</p><p>例子：二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 </p><h2 id="O-n-log-n"><a href="#O-n-log-n" class="headerlink" title="O(n log n)"></a>O(n log n)</h2><p>O(n log n)同理，就是n乘以log n，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于O(n)低于O(n^2)。</p><p>例子：归并排序，两个顺序序列合并成一个顺序序列，就是O(n log n)的时间复杂度。</p><p>原文地址：<a href="https://blog.csdn.net/lkp1603645756/article/details/85013126" target="_blank" rel="noopener">https://blog.csdn.net/lkp1603645756/article/details/85013126</a></p>]]></content>
    
    <summary type="html">
    
      这篇讲解O(1)、O(n)、O(n^2)、O(log n)、O(n log n)到底是个什么意思
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>可爱又易懂的贪心算法</title>
    <link href="http://yoursite.com/2019/12/04/%E5%8F%AF%E7%88%B1%E5%8F%88%E6%98%93%E6%87%82%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/04/%E5%8F%AF%E7%88%B1%E5%8F%88%E6%98%93%E6%87%82%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2019-12-04T05:53:22.000Z</published>
    <updated>2019-12-04T05:56:52.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不看后悔啊！"><a href="#不看后悔啊！" class="headerlink" title="不看后悔啊！"></a>不看后悔啊！</h4><p>源文地址：<a href="http://baijiahao.baidu.com/s?id=1642122740570394361&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1642122740570394361&amp;wfr=spider&amp;for=pc</a></p>]]></content>
    
    <summary type="html">
    
      今天本人在学贪心算法的时候，看到了一篇非常有意思的文章，一定要推荐给大家，既开心了，又学到东西了。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/12/03/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/12/03/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-12-03T10:50:01.000Z</published>
    <updated>2019-12-03T11:09:00.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-保证内存可见性"><a href="#1-保证内存可见性" class="headerlink" title="1. 保证内存可见性"></a>1. 保证内存可见性</h2><p>​        所有线程的共享变量都存储在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p>​        单线程环境下不会出现问题，而多线程会出现问题，会出现脏数据。</p><p>​        而volatile关键字可以使当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。所以说保证了内存可见性。</p><h2 id="2-禁止指令重排序"><a href="#2-禁止指令重排序" class="headerlink" title="2. 禁止指令重排序"></a>2. 禁止指令重排序</h2><p>​        指令的执行顺序并不一定会像我们编写的顺序那样执行，为了保证执行上的效率，JVM可能会对指令进行重排序。</p><p>​        而volatile关键字可以禁止指令重排序，即程序执行的顺序按照代码的先后顺序执行。</p><h2 id="3-不保证原子性"><a href="#3-不保证原子性" class="headerlink" title="3.不保证原子性"></a>3.不保证原子性</h2><p>​        也就是说，对volatile修饰的变量进行的操作，不保证多线程安全。</p><h2 id="4-单例模式的双重锁为什么要加volatile？"><a href="#4-单例模式的双重锁为什么要加volatile？" class="headerlink" title="4.单例模式的双重锁为什么要加volatile？"></a>4.单例模式的双重锁为什么要加volatile？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"> instance =<span class="keyword">new</span> Singleton();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance = new TestInstance();可以分解为3行伪代码</p><p>a.为instance分配内存</p><p>b.初始化instance</p><p>c.将instance变量指向分配的内存空间</p><p>上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象。</p>]]></content>
    
    <summary type="html">
    
      很常见的volatile关键字的作用
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java的反射到底是个啥？</title>
    <link href="http://yoursite.com/2019/11/30/java%E7%9A%84%E5%8F%8D%E5%B0%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/30/java%E7%9A%84%E5%8F%8D%E5%B0%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</id>
    <published>2019-11-30T05:49:55.000Z</published>
    <updated>2019-11-30T06:05:36.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请说明一下JAVA中反射的实现过程和作用分别是什么？"><a href="#请说明一下JAVA中反射的实现过程和作用分别是什么？" class="headerlink" title="请说明一下JAVA中反射的实现过程和作用分别是什么？"></a>请说明一下JAVA中反射的实现过程和作用分别是什么？</h2><p> JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：<strong>Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</strong> </p><p> 作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。 </p><h2 id="什么是反射-？"><a href="#什么是反射-？" class="headerlink" title="什么是反射 ？"></a><strong>什么是反射</strong> ？</h2><p> 反射就是把java类中的各种成分映射成一个个的Java对象 </p><p> 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 </p><h2 id="反射相关类常见的方法"><a href="#反射相关类常见的方法" class="headerlink" title="反射相关类常见的方法"></a><strong>反射相关类常见的方法</strong></h2><ul><li><strong>获得类相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>asSubclass(Class<U> clazz)</U></td><td>把传递的类的对象转换成代表其子类的对象</td></tr><tr><td>Cast</td><td>把对象转换成代表类或是接口的对象</td></tr><tr><td>getClassLoader()</td><td>获得类的加载器</td></tr><tr><td>getClasses()</td><td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td></tr><tr><td>getDeclaredClasses()</td><td>返回一个数组，数组中包含该类中所有类和接口类的对象</td></tr><tr><td>forName(String className)</td><td>根据类名返回类的对象</td></tr><tr><td>getName()</td><td>获得类的完整路径名字</td></tr><tr><td>newInstance()</td><td>创建类的实例</td></tr><tr><td>getPackage()</td><td>获得类的包</td></tr><tr><td>getSimpleName()</td><td>获得类的名字</td></tr><tr><td>getSuperclass()</td><td>获得当前类继承的父类的名字</td></tr><tr><td>getInterfaces()</td><td>获得当前类实现的类或是接口</td></tr></tbody></table><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getField(String name)</td><td>获得某个公有的属性对象</td></tr><tr><td>getFields()</td><td>获得所有公有的属性对象</td></tr><tr><td>getDeclaredField(String name)</td><td>获得某个属性对象</td></tr><tr><td>getDeclaredFields()</td><td>获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getAnnotation(Class<A> annotationClass)</A></td><td>返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td>getAnnotations()</td><td>返回该类所有的公有注解对象</td></tr><tr><td>getDeclaredAnnotation(Class<A> annotationClass)</A></td><td>返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td>getDeclaredAnnotations()</td><td>返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getConstructor(Class…&lt;?&gt; parameterTypes)</td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td>getConstructors()</td><td>获得该类的所有公有构造方法</td></tr><tr><td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td>getDeclaredConstructors()</td><td>获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td>获得该类某个公有的方法</td></tr><tr><td>getMethods()</td><td>获得该类所有公有的方法</td></tr><tr><td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td>获得该类某个方法</td></tr><tr><td>getDeclaredMethods()</td><td>获得该类所有方法</td></tr></tbody></table><ul><li><strong>类中其他重要的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>isAnnotation()</td><td>如果是注解类型则返回true</td></tr><tr><td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td><td>如果是指定类型注解类型则返回true</td></tr><tr><td>isAnonymousClass()</td><td>如果是匿名类则返回true</td></tr><tr><td>isArray()</td><td>如果是一个数组类则返回true</td></tr><tr><td>isEnum()</td><td>如果是枚举类则返回true</td></tr><tr><td>isInstance(Object obj)</td><td>如果obj是该类的实例则返回true</td></tr><tr><td>isInterface()</td><td>如果是接口类则返回true</td></tr><tr><td>isLocalClass()</td><td>如果是局部类则返回true</td></tr><tr><td>isMemberClass()</td><td>如果是内部类则返回true</td></tr></tbody></table><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>equals(Object obj)</td><td>属性与obj相等则返回true</td></tr><tr><td>get(Object obj)</td><td>获得obj中对应的属性值</td></tr><tr><td>set(Object obj, Object value)</td><td>设置obj中对应属性值</td></tr></tbody></table><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>invoke(Object obj, Object… args)</td><td>传递object对象及参数调用该对象对应的方法</td></tr></tbody></table><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>newInstance(Object… initargs)</td><td>根据传递的参数创建类的对象</td></tr></tbody></table><p>以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。</p><p>getMethod(parameterTypes)用来获取某个公有的方法的对象，</p><p>getMethods()获得该类所有公有的方法，</p><p>getDeclaredMethod(parameterTypes)获得该类某个方法，</p><p>getDeclaredMethods()获得该类所有方法。</p><p><strong>带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。</strong></p><p>其他的Annotation、Field、Constructor也是如此。</p>]]></content>
    
    <summary type="html">
    
      通俗易懂的理解java反射！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>rest?restful?到底是什么？</title>
    <link href="http://yoursite.com/2019/11/27/rest-restful-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/27/rest-restful-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2019-11-27T11:12:07.000Z</published>
    <updated>2019-11-27T11:16:10.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关于Rest"><a href="#1-关于Rest" class="headerlink" title="1.关于Rest"></a>1.关于Rest</h2><p>rest  :representational state transfer      表述性状态转移,是一种架构风格。</p><p>rest原则：</p><p>   &lt;1&gt;网络上的所有事物都被抽象为资源</p><p>   &lt;2&gt; 每个资源都有一个唯一的资源标识符</p><p>   &lt;3&gt; 同一个资源具有多种表现形式(xml,json等)</p><p>   &lt;4&gt;  对资源的各种操作不会改变资源标识符</p><p>   &lt;5&gt; 所有的操作都是无状态的 </p><h2 id="2-关于Restful"><a href="#2-关于Restful" class="headerlink" title="2.关于Restful"></a>2.关于Restful</h2><p>restful: 遵守了rest 原则 的web服务</p><p>理解：rest与restful相比，多了一个ful,就英语层面来说是一个形容词，restful翻译为中文为： “rest式的”</p><p>是rest式的什么呢？答案是 rest式的应用，rest风格的web服务也是rest式的应用，rest式的web服务是一种ROA(The Resource-Oriented Architecture)(面向资源的架构)，ROA听起来很高大上有没有。。</p><h2 id="3-两者的联系与区别"><a href="#3-两者的联系与区别" class="headerlink" title="3.两者的联系与区别"></a>3.两者的联系与区别</h2><p>restful是由rest派生出来的。</p><p>二.restful用法：</p><p>在Restful之前的操作：<br><a href="http://127.0.0.1/user/query/1" target="_blank" rel="noopener">http://127.0.0.1/user/query/1</a> GET  根据用户id查询用户数据<br><a href="http://127.0.0.1/user/save" target="_blank" rel="noopener">http://127.0.0.1/user/save</a> POST 新增用户<br><a href="http://127.0.0.1/user/update" target="_blank" rel="noopener">http://127.0.0.1/user/update</a> POST 修改用户信息<br><a href="http://127.0.0.1/user/delete" target="_blank" rel="noopener">http://127.0.0.1/user/delete</a> GET/POST 删除用户信息</p><p>RESTful用法：<br><a href="http://127.0.0.1/user/1" target="_blank" rel="noopener">http://127.0.0.1/user/1</a> GET  根据用户id查询用户数据<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  POST 新增用户<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  PUT 修改用户信息<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  DELETE 删除用户信息</p><p>之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了query,新增的时候用了save,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,我的意图很明显,完全没有必要做描述,这就是为什么有了restful.</p><p>原文链接：<a href="https://blog.csdn.net/weixin_41829196/article/details/79641911" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41829196/article/details/79641911</a></p>]]></content>
    
    <summary type="html">
    
      老听到Restful风格很有名，不知道什么东西，这篇就讲讲Restful到底是什么。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>理解数数据库事务隔离级别</title>
    <link href="http://yoursite.com/2019/11/27/%E7%90%86%E8%A7%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/27/%E7%90%86%E8%A7%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2019-11-27T05:51:08.000Z</published>
    <updated>2019-12-03T11:15:17.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据库事务隔离级别"><a href="#一、数据库事务隔离级别" class="headerlink" title="一、数据库事务隔离级别"></a><strong>一、数据库事务隔离级别</strong></h2><p> 数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。</p><p> 注意：我们讨论隔离级别的场景，主要是在多个事务并发 的情况下，因此，接下来的讲解都围绕事务并发。 </p><h3 id="Read-Uncommitted（未提交读）-："><a href="#Read-Uncommitted（未提交读）-：" class="headerlink" title="Read Uncommitted（未提交读） ："></a><strong>Read Uncommitted（未提交读）</strong> ：</h3><p> 事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。 </p><h3 id="EAD-COMMITTED-（提交读）："><a href="#EAD-COMMITTED-（提交读）：" class="headerlink" title="EAD COMMITTED （提交读）："></a><strong>EAD COMMITTED （提交读）</strong>：</h3><p>大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。 </p><h3 id="REPEATABLE-READ（重复读）-："><a href="#REPEATABLE-READ（重复读）-：" class="headerlink" title="REPEATABLE READ（重复读） ："></a><strong>REPEATABLE READ（重复读）</strong> ：</h3><p>保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”，但是带来了更多的性能损失。 </p><h3 id="erializable-（串行化）："><a href="#erializable-（串行化）：" class="headerlink" title="erializable （串行化）："></a><strong>erializable （串行化）</strong>：</h3><p>最严格的级别，事务串行执行，资源消耗最大； </p><h2 id="二、脏读、不可重复读、幻读"><a href="#二、脏读、不可重复读、幻读" class="headerlink" title="二、脏读、不可重复读、幻读"></a>二、<strong>脏读、不可重复读、幻读</strong></h2><h3 id="脏读（读取未提交数据）"><a href="#脏读（读取未提交数据）" class="headerlink" title="脏读（读取未提交数据）"></a>脏读（读取未提交数据）</h3><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p><p><strong>实例</strong>：公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高 兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有 2000元，singo空欢喜一场。</p><h3 id="不可重复读（前后多次读取，数据内容不一致）"><a href="#不可重复读（前后多次读取，数据内容不一致）" class="headerlink" title="不可重复读（前后多次读取，数据内容不一致）"></a>不可重复读（前后多次读取，数据内容不一致）</h3><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）</p><p><strong>实例</strong>：singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在 singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷</p><h3 id="幻读（前后多次读取，数据总量不一致）"><a href="#幻读（前后多次读取，数据总量不一致）" class="headerlink" title="幻读（前后多次读取，数据总量不一致）"></a>幻读（前后多次读取，数据总量不一致）</h3><p> 事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。</p><p> 实例：singo去银行查询老婆的消费记录，显示一共消费了1000元，正当singo将记录打印出来的时候， singo的老婆正好买完了一个500的包包并付了款，即新增了一条500元的消费记录且提交了事务。此时，singo打印出来的记录显示消费金额为1500元,singo很不解，以为出现了幻觉，幻读就这样产生了。 </p><h3 id="不可重复读和幻读比较："><a href="#不可重复读和幻读比较：" class="headerlink" title="不可重复读和幻读比较："></a><strong>不可重复读和幻读比较：</strong></h3><p>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p>]]></content>
    
    <summary type="html">
    
      数据库事务隔离级别，以及脏读，幻读，不可重复读的解释
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于锁的那点事!</title>
    <link href="http://yoursite.com/2019/11/26/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/11/26/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</id>
    <published>2019-11-26T03:48:22.000Z</published>
    <updated>2019-11-26T04:24:25.126Z</updated>
    
    <content type="html"><![CDATA[<p><strong>先来讲讲synchronized与java.util.concurrent.locks.Lock的相同之处和不同之处？</strong></p><p> 主要相同点：Lock能完成synchronized所实现的所有功能<br> 主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序   员手工释放，并且必须在finally从句中释放。 </p><p> 用法上的不同：<br> synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置。<br> synchronized是托管给JVM执行的，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义。</p><p>性能上的不同：<br> lock接口的实现类ReentrantLock，不仅具有和synchronized相同的并发性和内存语义，还多了超时的获取锁、定时锁、  等候和中断锁等。<br> 在竞争不是很激烈的情况下，synchronized的性能优于ReentrantLock，竞争激烈的情况下synchronized的性能会下降的非常快，而ReentrantLock则基本不变。</p><p>锁机制不同：<br> synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁。 </p><p><strong>再来讲讲其他关于锁的概念？</strong></p><p>锁大概有以下名词：<br><strong>自旋锁 ，自旋锁的其他种类</strong>，阻塞锁，可重入锁 ，<strong>读写锁</strong> ，<strong>互斥锁</strong> ，<strong>悲观锁</strong> ，<strong>乐观锁</strong> ，<strong>公平锁</strong> ，<strong>偏向锁</strong>， 对象锁，线程锁，<strong>锁粗化</strong>， <strong>锁消除</strong>，<strong>轻量级锁</strong>，<strong>重量级锁</strong>， 信号量，<strong>独享锁</strong>，<strong>共享锁</strong>，<strong>分段锁</strong>  </p><p> Synchronized，它就是一个：非公平，悲观，独享，互斥，可重入的重量级锁 </p><p> ReentrantLock，它是一个：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁。 </p><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p><strong>公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</strong>。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，<strong>通过构造函数指定该锁是否是公平锁，默认是非公平锁。</strong>非公平锁的优点在于吞吐量比公平锁大。对于<strong>Synchronized而言，也是一种非公平锁</strong>。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<strong>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式</strong>。悲观的认为，不加锁的并发操作一定会出问题。<strong>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</strong>从上面的描述我们可以看出，<strong>悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景</strong>，不加锁会带来大量的性能提升。<strong>悲观锁在Java中的使用，就是利用各种锁</strong>。<strong>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</strong></p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p><strong>独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有</strong>。<strong>对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁</strong>。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<strong>对于Synchronized而言，当然是独享锁。</strong></p><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是<strong>ReentrantLock</strong>，<strong>读写锁在Java中的具体实现就是ReentrantReadWriteLock</strong></p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，<strong>其名字是Reentrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。</strong>可重入锁的一个好处是可一定程度<strong>避免死锁</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public sychrnozied void test() &#123;    </span><br><span class="line">xxxxxx;   </span><br><span class="line">test2();</span><br><span class="line">&#125; </span><br><span class="line">public sychronized void test2() &#123;    </span><br><span class="line">yyyyy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码段中，执行 test 方法需要获得当前对象作为监视器的对象锁，但方法中又调用了 test2 的同步方法。</p><ul><li><strong>如果锁是具有可重入性的话，那么该线程在调用 test2 时并不需要再次获得当前对象的锁，可以直接进入 test2 方法进行操作。</strong></li><li><strong>如果锁是不具有可重入性的话，那么该线程在调用 test2 前会等待当前对象锁的释放，实际上该对象锁已被当前线程所持有，不可能再次获得。</strong></li></ul><p>如果锁是不具有可重入性特点的话，<strong>那么线程在调用同步方法、含有锁的方法时就会产生死锁。</strong></p><h2 id="自旋锁-自适应自旋锁"><a href="#自旋锁-自适应自旋锁" class="headerlink" title="自旋锁/自适应自旋锁"></a>自旋锁/自适应自旋锁</h2><p>在Java中，<strong>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><h2 id="锁粗化-锁消除"><a href="#锁粗化-锁消除" class="headerlink" title="锁粗化/锁消除"></a>锁粗化/锁消除</h2><p><strong>锁消除</strong>是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h2><p><strong>这三种锁是指锁的状态</strong>，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。<strong>这三种锁的状态是通过对象监视器在对象头中的字段来表明的</strong>。</p><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</strong>。</p><p><strong>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁</strong>，不会阻塞，提高性能。</p><p><strong>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。</strong>重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，<strong>对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作</strong>。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，<strong>ConcurrentHashMap中的分段锁称为Segment</strong>，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即<strong>内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)</strong>。</p><p>当需要put元素的时候，并不是对整个hashmap进行加锁，而是<strong>先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁</strong>，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<strong>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</strong></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p> 两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。 </p><p> 例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 </p><h2 id="synchronized的可重入怎么实现"><a href="#synchronized的可重入怎么实现" class="headerlink" title="synchronized的可重入怎么实现"></a>synchronized的可重入怎么实现</h2><p>每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。 </p><h2 id="非公平锁和公平锁在reetrantlock里的实现过程"><a href="#非公平锁和公平锁在reetrantlock里的实现过程" class="headerlink" title="非公平锁和公平锁在reetrantlock里的实现过程"></a>非公平锁和公平锁在reetrantlock里的实现过程</h2><p> 如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO(队列,先进先出)。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 </p><h2 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h2><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。</p><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p><p>参考地址：<a href="https://blog.csdn.net/qq_41931837/article/details/82314478" target="_blank" rel="noopener">https://blog.csdn.net/qq_41931837/article/details/82314478</a></p>]]></content>
    
    <summary type="html">
    
      讲述同步与锁的区别，以及各种常见的锁的概念。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Interface与abstract类的区别</title>
    <link href="http://yoursite.com/2019/11/24/Interface%E4%B8%8Eabstract%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/24/Interface%E4%B8%8Eabstract%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-24T13:15:02.000Z</published>
    <updated>2019-11-24T13:32:10.075Z</updated>
    
    <content type="html"><![CDATA[<p>一.在jdk8之前</p><p>1.抽象类(abstract)中可以普通属性，普通方法，抽象方法，构造方法（但不能实例），和平常的方法一样；</p><p>而接口中只能public final static属性和 public abstract 抽象方法，无构造方法，当然不能实例；</p><p>2.一个类只能继承一个抽象类；一个接口可以继承多个接口；一个类可以同时实现多个接口；</p><p>3.通常使用抽象类表示一个概念（一类事物），而接口表示一种能力</p><p>4.如果子类是接口，父类也必须是接口。</p><p>5.抽象类可以无抽象方法，但有抽象方法的必须是抽象类，抽象方法无方法体。</p><p>6.抽象类表示的是“is-a”关系（继承关系） ，接口表现的是“like-a”关系 (组合关系)，还有is-like-a组合关系， instance of：实例关系 </p><p>二.jdk8之后 </p><p>关于抽象类</p><p>JDK 1.8以前，抽象类的方法默认访问权限为protected</p><p>JDK 1.8时，抽象类的方法默认访问权限变为default</p><p>关于接口</p><p>JDK 1.8以前，接口中的方法必须是public的</p><p>JDK 1.8时，接口中的方法可以是public的，也可以是default的</p><p>接口中可以有default方法和static方法 </p><p>default method in interface 默认方法</p><p>简单说，就是接口可以有实现方法，而且不需要实现类去实现其方法。只需在方法名前面加个default关键字即可。</p><p>JDK 1.9时，接口中的方法可以是private的</p>]]></content>
    
    <summary type="html">
    
      接口和抽象类的区别，包含jdk1.8新特性
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM堆内存设置原理</title>
    <link href="http://yoursite.com/2019/11/23/JVM%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/23/JVM%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2019-11-23T11:14:29.000Z</published>
    <updated>2019-11-26T03:21:55.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>JVM堆内存分为2块：Permanent Space 和 Heap Space。</p><ul><li>Permanent 即 <strong>持久代</strong>（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。</li><li>Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 <strong>年轻代</strong>（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</li></ul><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。</p><p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p><p>2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。<strong>而且，因为需要交换的原因，Survivor区至少有一个是空的</strong>。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p>针对年轻代的垃圾回收即 Young GC。</p><h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>针对年老代的垃圾回收即 Full GC。</p><h3 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h3><p>用于存放静态类型数据，如 Java Class, Method  等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib  等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</p><p>简述：</p><p>1.新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor  GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor  GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。<br>2.老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full  GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。<br>3.持久代：持久代如果满了，将触发Full GC。 </p><p>所以，当一组对象生成时，<strong>内存申请过程</strong>如下：</p><ol><li>JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。</li><li>当Eden区空间足够时，内存申请结束。否则执行下一步。</li><li>JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。</li><li>Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。</li><li>当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。</li><li>Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。</li></ol><p><strong>OOM（“Out of Memory”）异常一般主要有如下2种原因</strong>：</p><p>\1. 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace</p><p>这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。</p><p>例如<strong>循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存</strong>。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。</p><p> \2. 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace</p><p>通常由于持久代设置过小，<strong>动态加载了大量Java类而导致溢出</strong>，解决办法唯有将参数  -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share  lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul><li>-Xmx3550m：设置JVM<strong>最大堆内存</strong>为3550M。</li><li>-Xms3550m：设置JVM<strong>初始堆内存</strong>为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-XX:SurvivorRatio=4：设置<strong>年轻代中Eden区与Survivor区的比值</strong>。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。 </li><li>等等还有很多这三个常见</li></ul><p>这些只是JVM堆内存的一部分基础知识，想看详细的还需要自己去总结并且网上多多查询积累，这里面其实还有一部分非常重要的内容，那便是<strong>java的垃圾回收机制</strong>，这块还是得单独拿出来好好写一写，东西比较多，而且很重要。今天就先写这一篇了!!!</p>]]></content>
    
    <summary type="html">
    
      牛客刷题，经常碰见的类型，没办法，必须总结下来好好看看了，要不然还是老忘不会
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>final关键字</title>
    <link href="http://yoursite.com/2019/11/22/final/"/>
    <id>http://yoursite.com/2019/11/22/final/</id>
    <published>2019-11-22T12:03:39.000Z</published>
    <updated>2019-11-22T12:07:55.957Z</updated>
    
    <content type="html"><![CDATA[<p>  final修饰的方法，不允许被子类覆盖。 </p><p>  final修饰的类，不能被继承。 </p><p>  final修饰的变量，不能改变值。 </p><p>  final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。 </p><p> final修饰的成员变量在赋值时可以有三种方式。1、在声明时直接赋值。2、在构造器中赋值。3、在初始代码块中进行赋值。  </p><p> 对于static final修饰的变量，其定义可以有两处。1、变量申明处，2、静态构造代码块。 </p><p> static  final和final之间的区别是，前者代表对于一个类恒定不变的属性，后者代表对于一个类来说恒定不变的属性，但是对于同一个类不同对象之间还是可以变换的。 </p>]]></content>
    
    <summary type="html">
    
      final关键字的用法以及特性
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HashMap的底层原理</title>
    <link href="http://yoursite.com/2019/11/22/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/22/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2019-11-22T07:15:02.000Z</published>
    <updated>2019-11-23T09:59:30.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-HashMap的原理"><a href="#一-HashMap的原理" class="headerlink" title="一.HashMap的原理"></a><strong>一.HashMap的原理</strong></h3><p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p><p> HashMap的好处非常多，我们会经常用到HashMap和ConcurrentHashMap。 </p><p>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口。</p><p>HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；由于它的键可以是为空的，所以，所以我们不能用get（key）判断是否有这个键，而应该用containsKey（）这个方法来判断是否有这个键；</p><p>HashMap数据结构的优点    1.适合海量数据   2.o(1)的随机访问速度，不是可遍历。</p><p> HashMap默认容量为16，且要求容量一定为2的整数次幂。 </p><h3 id="二-HashMap和Hashtable的区别"><a href="#二-HashMap和Hashtable的区别" class="headerlink" title="二.HashMap和Hashtable的区别"></a><strong>二.HashMap和Hashtable的区别</strong></h3><p> HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度 </p><p>1.HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p>2.HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 </p><p>3.由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 </p><p>4.HashMap不能保证随着时间的推移Map中的元素次序是不变的。 </p><p>5.HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap); </p><p>6.Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</p><h3 id="三-HashMap和HashSet的区别"><a href="#三-HashMap和HashSet的区别" class="headerlink" title="三.HashMap和HashSet的区别"></a>三.HashMap和HashSet的区别</h3><p> 1.HashMap实现了Map接口 ,HashSet实现了Set接口 </p><p> 2.HashMap储存键值对 ,HashSet仅仅存储对象 </p><p>3.HashSet仅仅存储对象 , ,HashSet使用add()方法将元素放入set中 </p><p>4.HashMap中使用键对象来计算hashcode值 , HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false </p><p>5.HashSet较HashMap来说比较慢 </p><h3 id="四-CurrentHashMap和HashMap的区别"><a href="#四-CurrentHashMap和HashMap的区别" class="headerlink" title="四.CurrentHashMap和HashMap的区别"></a>四.CurrentHashMap和HashMap的区别</h3><p>在jdk1.5的时候就出来了CurrentHashMap来弥补HashMap的线程不安全的特性；CurrentHashMap，是将HashMap分成了很多个片（一般默认是16片），引入了分段锁的概念，然后对每一片加锁，具体可以理解成一把大的Map分解成N个小的HashTable，根据key.hashCode()来决定放到哪一个片上；</p><p>由于安全机制的原因，HashMap的效率比HashTable，CurrentHashMap的效率高；但是由于CurrentHashMap加锁的高效性,HashTable是整个加锁，他的效率比HashTable高； 总的来说 <strong>HashMap&gt;CurrentHashMap&gt;HashTable;</strong></p><p>CurrentHashMap的问题还得单独拿出来说一下，东西挺多的，等我在另外一篇博客总结一下吧。</p><h3 id="五-最重要的来了，面试题！"><a href="#五-最重要的来了，面试题！" class="headerlink" title="五.最重要的来了，面试题！"></a><strong>五.最重要的来了，面试题！</strong></h3><p> 1.“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 答案如下:</p><p> HashMap是基于hashing的原理，我们使用put(key,  value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。 </p><p> 2.下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： </p><p> “当两个对象的hashcode相同会发生什么？”      因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。 </p><p> “如果两个键的hashcode相同，你如何获取值对象？”    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置 ,找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！  </p><p>3.’’如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办?’’ :</p><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 </p><p>4.“你了解重新调整HashMap大小存在什么问题吗？” </p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail  traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ </p><p>5.为什么String, Interger这样的wrapper类适合作为键？ </p><p>一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 </p><p> 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 </p><p> 6.我们可以使用CocurrentHashMap来代替Hashtable吗？</p><p>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性 </p><p>这已经是非常全的内容和面经了，东西虽然多，但是非常重要，希望我自己也能滚瓜乱熟！</p><p>借鉴文章地址：<a href="https://blog.csdn.net/suifeng629/article/details/82179996" target="_blank" rel="noopener">https://blog.csdn.net/suifeng629/article/details/82179996</a></p>]]></content>
    
    <summary type="html">
    
      HashMap的原理以及和HashTable，CurrentHashMap，TreeMap的区别，程序员新手老生常谈的问题，必看！通俗易懂，而且全，有面试的更加推荐奥！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://yoursite.com/2019/11/22/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/11/22/%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2019-11-22T07:00:47.000Z</published>
    <updated>2019-11-22T07:07:48.101Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/.com//C:%5CUsers%5Cqq%5CDesktop%5Cprogram%5CHexoBlog%5Csource_posts%5C%E5%86%85%E9%83%A8%E7%B1%BB%5C%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="内部类"></p>]]></content>
    
    <summary type="html">
    
      内部类大全，拿走不谢！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javac和java的区别</title>
    <link href="http://yoursite.com/2019/11/22/javac%E5%92%8Cjava%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/22/javac%E5%92%8Cjava%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-22T06:44:47.000Z</published>
    <updated>2019-11-22T06:45:26.145Z</updated>
    
    <content type="html"><![CDATA[<p>cmd中，执行java命令与javac命令的区别：</p><p><strong>javac</strong>：是编译命令，将java源文件编译成.class字节码文件。</p><p>例如：<strong>javac hello.java</strong></p><p>将生成<strong>hello.class</strong>文件。</p><p><strong>java</strong>：是运行字节码文件；由java虚拟机对字节码进行解释和运行。</p><p>例如：<strong>java hello</strong>（相当于运行.exe文件）</p>]]></content>
    
    <summary type="html">
    
      简述javac和java命令
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Interger方法</title>
    <link href="http://yoursite.com/2019/11/22/Interger%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/22/Interger%E6%96%B9%E6%B3%95/</id>
    <published>2019-11-22T06:43:28.000Z</published>
    <updated>2019-11-22T06:44:21.544Z</updated>
    
    <content type="html"><![CDATA[<p>  Integer.parseInt(“”);是将字符串类型转换为int的基础数据类型 </p><p>  Integer.valueOf(“”)是将字符串类型数据转换为Integer对象 </p><p>  Integer.intValue();是将Integer对象中的数据取出，返回一个基础数据类型int </p><p>牛客的一道例题：</p><p>  a = Integer.parseInt(“1024”);  </p><p>  b = Integer.valueOf(“1024”).intValue();     </p><p>小伙伴认为是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a和b都是整数类型变量并且它们的值相等</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Interger包装类常用方法，面试用奥
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象5大基本原则</title>
    <link href="http://yoursite.com/2019/11/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/11/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2019-11-22T06:42:11.000Z</published>
    <updated>2019-11-22T06:43:01.971Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>单一职责原则（SRP）</strong>：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。<br> <strong>开放封闭原则（OCP）</strong>：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。<br> <strong>Liskov替换原则（LSP）</strong>：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。<br> <strong>依赖倒置原则（DIP）</strong>：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。<br> <strong>接口隔离原则（ISP）</strong>：使用多个小的专门的接口，而不要使用一个大的总接口 。</p><p>很多同学或者新手学了java也挺长时间了，但五大基本原则有的还都没有听说过，最近在牛客网刷题，既然考出来了就给大家放上去吧。看看，嘻嘻！</p>]]></content>
    
    <summary type="html">
    
      java面向对象
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>远程数据库导入本地</title>
    <link href="http://yoursite.com/2019/11/21/%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/"/>
    <id>http://yoursite.com/2019/11/21/%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/</id>
    <published>2019-11-21T04:20:56.000Z</published>
    <updated>2019-11-22T05:14:09.987Z</updated>
    
    <content type="html"><![CDATA[<p>本人在刚上大三的时候，和同学接了一个小项目，是一个老师的监督管理系统，也是第一次有稍稍多的数据量（小声哔哔，对我这种菜鸟已经算多了)几千条左右。那时，朋友将数据全部都导入到了他的MySql中，并修改了部分，我去和他要，他让我自己导入进去，没办法只能上网搜索，没想到还挺简单。这次，记录下来也是为了让自己记住，下次可以一起性搞定！</p><p>一.Ctrl+R 打开CMD</p><p>二.输入                                                                                                                                                    <strong>mysqldump -h 111.111.111.111  -uROSE -pPASSWORD  –port  3306   –opt   –compress  sdbname</strong>  </p><p><strong>–skip-lock-tables |  mysql -h  localhost  -uroot -proot  dbname</strong></p><p>三.<font color="red">注意事项</font>(千万注意，我就是弄混了，输错了好几遍！)</p><p><strong>111.111.111.111</strong> 远程服务器ip </p><p><strong>ROSE</strong> 远程数据库用户名</p><p><strong>PASSWORD</strong> 远程数据库用户密码</p><p><strong>3306</strong> 远程数据库使用的端口</p><p><strong>sdbname</strong> 要导入的源数据库名</p><p><strong>dbname</strong> 要导入的目的数据库名</p><p>转载地址： <a href="https://blog.csdn.net/gj591851/article/details/45287953" target="_blank" rel="noopener">https://blog.csdn.net/gj591851/article/details/45287953</a> </p>]]></content>
    
    <summary type="html">
    
      这篇讲解如何将远程数据库导入本地数据库
    
    </summary>
    
    
    
  </entry>
  
</feed>
