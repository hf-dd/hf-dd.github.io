<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HF Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-01T16:00:17.903Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis和mysql的数据一致性</title>
    <link href="http://yoursite.com/2020/02/01/Redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2020/02/01/Redis%E5%92%8Cmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2020-02-01T15:05:20.000Z</published>
    <updated>2020-02-01T16:00:17.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用Redis缓冲读数据的流程为："><a href="#利用Redis缓冲读数据的流程为：" class="headerlink" title="利用Redis缓冲读数据的流程为："></a><strong>利用Redis缓冲读数据的流程为：</strong></h3><p>开始读，判断缓冲中是否有数据，有则返回给客户端，没有的话就会去数据库中查询，如果还没有就返回没有，如果有的话就会写入缓冲中，再返回客户端。</p><p>一般业务操作都是该流程，读的话可以看出不会出现太大问题，但如果有数据的更新呢？那么就会产生一些问题了。</p><h3 id="可能会出现的问题："><a href="#可能会出现的问题：" class="headerlink" title="可能会出现的问题："></a><strong>可能会出现的问题：</strong></h3><p>更新数据的时候，先更新数据库，然后要删除缓存旧的数据，但是没有删除成功，此时数据库和缓存的数据就发生了不一致。</p><p>改进：要求先删除缓存数据成功后，再更新数据库，这样保证数据一致性。</p><p>但还是会有问题：删除缓存数据成功后，更新数据库的操作还没执行完的时候，另一个线程就来读数据，此时缓存为空，去数据库查找，此时数据库的数据还是没更新前的，读取到然后传给缓存。这时候数据库成功更新了数据，接下来就知道了，数据库和缓存的数据不一致了。</p><h3 id="那么到底如何解决一致性问题呢？"><a href="#那么到底如何解决一致性问题呢？" class="headerlink" title="那么到底如何解决一致性问题呢？"></a><strong>那么到底如何解决一致性问题呢？</strong></h3><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。我们接下来考虑的都不是设置过期时间的方法。</p><p><strong>1.采用延时双删策略</strong></p><p>先删除缓存，再写数据库，休眠500毫秒，再次删除缓存。这样可以确保另一个线程读请求结束，写请求可以删除读请求造成的缓存脏数据（就是上述问题）。休眠时间看自己情况。</p><p><strong>2.异步更新缓存(基于订阅binlog的同步机制)</strong></p><p>binlog二进制日志文件，记录所有增删改的SQL语句，不记录查的语句，因为没有对数据进行修改。</p><p>这样，一旦数据库数据发生更新，就把binlog推给Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>MySQL的主从备份机制也是利用binlog来实现数据一致性，binlog记录推送给Redis的方式可以采用常见的消息队列就行。</p>]]></content>
    
    <summary type="html">
    
      读数据从Redis缓存，那么如何保证Redis和mysql数据是一致的呢。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git常用的三个命令！</title>
    <link href="http://yoursite.com/2020/02/01/Git%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%81/"/>
    <id>http://yoursite.com/2020/02/01/Git%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%91%BD%E4%BB%A4%EF%BC%81/</id>
    <published>2020-02-01T14:53:27.000Z</published>
    <updated>2020-02-01T14:58:13.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 是把要传的数据添加到一个仓库或者说是暂存区，意思就是先放在里面，告诉它们我们将要对这些数据进行操作了。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>而git commit就是进行操作的第一步，就是将本地修改过的文件提交到本地库中。</p><p><strong>git push</strong></p><p>第二步就是git push，将本地库中的最新信息发送给远程库，供其他人可见。</p>]]></content>
    
    <summary type="html">
    
      Git的add,push,commit
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BIO,NIO,AIO</title>
    <link href="http://yoursite.com/2020/01/31/BIO-NIO-AIO/"/>
    <id>http://yoursite.com/2020/01/31/BIO-NIO-AIO/</id>
    <published>2020-01-31T05:50:18.000Z</published>
    <updated>2020-01-31T07:15:47.928Z</updated>
    
    <content type="html"><![CDATA[<p>1.同步：使用同步IO时，Java自己处理IO读写。</p><p>2.异步：使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS，完成后OS通知Java处理（回调）。</p><p>3.阻塞：使用阻塞IO时，Java调用会一直阻塞到读写完成才返回。</p><p>4.非阻塞：使用非阻塞IO时，如果不能立马读写，Java调用会马上返回，当IO事件分发器通知可读写时在进行读写，不断循环直到读写完成。</p><p>下面是重点了（敲黑板！）！</p><p>1.BIO：<strong>同步并阻塞</strong>，服务器的实现模式是<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，可能造成不必要的线程开销，当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。</p><p>2.NIO：在JDK1.4以前，Java的IO模型一直是BIO，但从JDK1.4开始，JDK引入的新的IO模型NIO，它是<strong>同步非阻塞</strong>的。而服务器的实现模式是<strong>多个请求一个线程</strong>，即请求会注册到多路复用器Selector上，<strong>多路复用器</strong>轮询到连接有IO请求时才启动一个线程处理。    </p><p>3.AIO：JDK1.7发布了NIO2.0，这就是真正意义上的<strong>异步非阻塞</strong>，服务器的实现模式为<strong>多个有效请求一个线程</strong>，客户端的IO请求<strong>都是由OS先完成再通知</strong>服务器应用去启动线程处理（回调）。</p><p>应用场景：并发连接数不多时采用BIO，因为它编程和调试都非常简单，但如果涉及到高并发的情况，应选择NIO（连接数目多且连接比较短）或AIO（连接数目多且连接比较长），更好的建议是采用成熟的网络通信框架Netty。</p>]]></content>
    
    <summary type="html">
    
      Java中BIO、NIO和AIO的区别和应用场景
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>事务以及分布式事务！</title>
    <link href="http://yoursite.com/2020/01/30/%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/30/%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%81/</id>
    <published>2020-01-30T03:27:02.000Z</published>
    <updated>2020-01-30T04:55:16.777Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务提供一种“要么什么都不做，要么都做”的机制，她有ACID四大特性：</p><p>原子性（A）：一个事务是一个不可分割的工作单位，要么都做，要么都不做。</p><p>一致性（C）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致状态是指数据库中的数据应满足完整性约束。</p><p>隔离性（I）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p><p>持久性（D）：已被提交的事务对数据库的修改应该永久性的。</p><p><strong>单机事务</strong>：事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><strong>XA协议</strong>包含<strong>两阶段提交（2PC）</strong>和<strong>三阶段提交（3PC）</strong>两种实现。</p><p><strong>两阶段提交（2PC）</strong>：包含俩个角色<strong>事务协调者</strong>TM和<strong>事务参与者</strong>AP。</p><p><strong>第一阶段</strong>：事务协调者首先向所有的事务参与者发送Prepare请求。每个参与者执行相关事务操作Undo Log和Redo Log，如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。得到了所有参与者成功消息后，进入第二阶段。</p><p><strong>第二阶段</strong>：因为前面都是成功消息，事务协调者会向所有事务参与者发送Commit请求，接到请求后事务参与者各自会进行事务提交，释放锁，然后返回协调者“完成”消息。整个流程完成。</p><p><strong>出错流程</strong>：第一阶段如果都发送Prepare请求后，有一个或多个参与者返回了错误消息，必须进行回滚，所以第二阶段事务协调者会向所有参与者发送Abort请求，之后所有参与者进行回滚，回滚操作依照Undo Log来进行。</p><p>缺点：<strong>1.性能问题</strong>，只有所有节点都准备好，事务才能提交，很明显性能很差。<strong>2.协调者单点故障问题</strong>，事务协调者一宕机，基本就全完了。<strong>3.丢失消息导致的不一致问题</strong>，不同事务参与者因为消息的丢失，导致节点数据不一样了。</p><p><strong>解决方法：</strong></p><p><strong>XA三阶段提交</strong>：在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。有效解决了协调者单点故障的问题，协调者挂掉，其他参与者超时得不到消息会自行本地commit。</p><p><strong>MQ事务</strong>：引入了消息中间件（助理），负责消息的传递和事务执行状态的询问。这样就降低了系统间的耦合度，解决了性能问题。</p><p><strong>TCC事务</strong>：TCC指的是Try(尝试)、Confirm（确认）、Cancle（取消）,其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。跟两阶段提交（2PC）比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些。</p><p><strong>拓展：</strong></p><p>CAP定理</p><p>CAP原则又称CAP定理，指的是在一个分布式系统中，WEB服务无法同时满足以下3个特性：</p><pre><code>一致性(Consistency) ： 在分布式系统中数据一旦更新，所有数据变动都是同步的可用性(Availability) ： 好的响应性能，每个操作都必须有预期的响应结束分区容错性(Partition tolerance) ： 在网络分区的情况下，即使出现单个节点无法可用，系统依然正常对外提供服务</code></pre><p>首先在分布式系统中，横向扩展策略依赖于数据分区，所以一般会在一致性和可用性上做出牺牲。</p>]]></content>
    
    <summary type="html">
    
      面试高频的事务，必须总结一番
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>进程的通信方式?</title>
    <link href="http://yoursite.com/2020/01/27/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/27/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2020-01-27T13:09:36.000Z</published>
    <updated>2020-01-31T13:28:45.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h3><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。</p><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。</p><h3 id="IPC通信方式"><a href="#IPC通信方式" class="headerlink" title="IPC通信方式"></a>IPC通信方式</h3><p>管道（无名管道，高级管道，命名管道），消息队列，信号量机制，共享内存，套接字。</p><p><strong>无名管道（匿名管道）pipe：</strong>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系兄弟进程关系。</p><p>当一个管道建立时，它会创建两个文件描述符：<code>fd[0]</code>为读而打开，<code>fd[1]</code>为写而打开。基于字节流</p><p>例如父进程数据流入子进程，关闭父进程的读端 fd[0] 与子进程的写端 fd[1]，让数据从父进程写端流入子进程读端，反之同理。</p><p><strong>高级管道（popen）：</strong>将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p><strong>命名管道（FIFO）：</strong>FIFO也是半双工的通信方式，允许无亲缘关系进程间的通信。FIFO有路径名与之相关联，是一种文件类型。</p><p><strong>消息队列：</strong>消息的链接表，存放在内核中。一个消息队列由一个标识符（即<strong>队列ID</strong>）来标识。可以直接在进程间传送消息，较高级，可被多线程所共享，面向记录（数据特定格式），可实现随机查询，不一定要按先进先出次序读取。</p><p><strong>信号量机制：</strong>信号量加一减一，简单PV操作，实现同步和互斥，操作系统都讲过。</p><p><strong>共享内存：</strong>指两个或多个进程共享一个给定的存储区。共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式（因为直接对内存进行存取），它是针对其他进程间通信方式运行效率低而专门设计的。因为多个进程可以同时操作，所以需要进行同步，通常信号量+共享内存结合在一起使用。</p><p><strong>套接字：</strong>它和别的通信方式最主要不同的是可用于不同机器间的进程通信。</p>]]></content>
    
    <summary type="html">
    
      进程间通信IPC的几种方式？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JVM的垃圾回收机制！</title>
    <link href="http://yoursite.com/2020/01/25/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/25/JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%81/</id>
    <published>2020-01-25T13:48:11.000Z</published>
    <updated>2020-01-29T03:44:23.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类加载器子系统"><a href="#1-类加载器子系统" class="headerlink" title="1.类加载器子系统"></a>1.类加载器子系统</h3><p>Java的动态类加载功能是由类加载器子系统处理。采用的是双亲委派机制（加载类先交给上层父类加载）</p><p>启动类加载器 (BootStrap class Loader)：启动时初始加载一些包，<strong>rt.jar</strong>，根加载器，拥有最高权限。</p><p>扩展类加载器(Extension class Loader)：加载扩展功能的一些jar包。</p><p>应用程序类加载器(System ClassLoader)：加载class path下的所有类。</p><h3 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2.运行时数据区"></a>2.运行时数据区</h3><p>方法区（Method Area）：所有类，静态变量，静态方法，成员方法，常量，共享（线程不安全）。</p><p>堆区（Heap Area）：所有对象和他的实例new出来的，数组，共享（不安全）。</p><p>栈区（Stack Area）：局部变量，对象的引用，每个线程创建（安全）。</p><p>程序计数器：（唯一一个不抛出OOM）保存当前线程执行的内存地址。安全</p><p>本地方法栈：为JVM使用到的native方法服务。</p><h3 id="3-GC（垃圾回收）"><a href="#3-GC（垃圾回收）" class="headerlink" title="3.GC（垃圾回收）"></a>3.GC（垃圾回收）</h3><p>GC的作用：  排查内存溢出，排查内存泄漏，性能调优，排查并发瓶颈</p><p>GC做了什么：哪些内存需要回收？什么时候回收？如何回收？</p><h4 id="哪些内存需要回收？"><a href="#哪些内存需要回收？" class="headerlink" title="哪些内存需要回收？"></a>哪些内存需要回收？</h4><p>回收已经”死“的内存，哪些已”死“？</p><p>对象没有引用，作用域发生未捕获异常，程序在作用域正常执行完毕，程序执行了System.exit()，程序发生意外终止（被杀进程等）</p><p><strong>判断已死方法</strong>：最早的引用计数法，引用一个对象时，计数器加一，引用失效，减一。为0时判断已死，有弊端，无法解决循环引用问题，所有java不使用该方法。而采用的方法为<strong>可达性分析算法</strong>，从根节点GC ROOT开始，向下寻找它的引用节点，没有找到的节点就是无用可回收节点。</p><p>可作为GC Roots的对象包含以下几种：</p><ol><li>虚拟机栈中引用的对象。</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中(Native方法)引用的对象</li></ol><h4 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h4><p>引用的分类：强引用（只要强引用在，永远不回收），软引用（内存够，就不回收，不够就回收了），弱引用（不管内存够不够都回收），虚引用（每次都回收）。</p><p><strong>可达性分析算法</strong>后标记的无用节点，并不是直接回收，会再进行一次筛选判断有必要执行finalize()，没有则死，有则得到一次最后逃脱死亡的机会。</p><p><strong>类被回收的条件</strong>：该类的所有实例都已经被回收(即在Java堆中不存在任何该类的实例)，加载该类的ClassLoader已被回收，该类对应的Class对象没有任何其他地方被引用，无法在任何地方通过反射访问该类的方法。</p><h4 id="如何回收？"><a href="#如何回收？" class="headerlink" title="如何回收？"></a>如何回收？</h4><p><strong>标记-清除算法</strong>：先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>缺点：效率低，会产生内存碎片。</p><p><strong>复制算法</strong>：将内存分成大小相同俩块，每次只用一块。第一块回收完，将活着的对象放到另外一块，第一块彻底清理，下次一样。效率高，不会产生内存碎片。</p><p><strong>标记-整理算法</strong>：在标记-清除算法的基础上，回收后将存活对象都推到左端空闲区域，解决内存碎片问题。</p><p><strong>JVM的优化：</strong>采用分代回收方式。</p><p>新生代内存的回收（minor GC）主要采用复制算法，新生代分成三部分，Eden,  Survivor  From，Survivor To=8:1:1。 将Eden和From区存活对象，放入To区，清空前面俩区，下次就是Eden和To到From，Survivor内存不够时，存入老年代。</p><p>老年代内存回收（Full GC，Major GC）主要采用标记-整理算法。</p><p>区别：新生代，每次有大量对象产生，大量对象被回收，次数频繁，因此采用效率高，速度快的复制算法。</p><p>老年代，对象存活率高，没有额外空间对它进行分配，采用标记-整理算法，次数少，Major GC的速度一般会比Minor GC慢10倍以上。</p><p><strong>JVM垃圾回收器</strong>：串行（Serial），并行（Parallel,ParNew），并发（CMS）</p><p>Serial收集器：JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止.</p><p>串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。</p><p>Serial收集器默认新旧生代的回收器搭配为Serial+ SerialOld.</p><p> ParNew收集器：多CPU模式下的首选回收器，也是Server模式下的默认收集器。</p><p>ParallelScavenge收集器：又被称为是吞吐量优先的收集器。    </p><p>ParallelOld收集器：是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。</p><p><strong>CMS</strong>：又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法。</p><p>过程为：初始标记，并发标记，重新标记，并发清除。</p><p>优点：并发收集、低停顿。</p><p>缺点：CMS收集器对CPU资源非常敏感，占CPU资源，且总吞吐量下降，基于标志-清除算法，会产生碎片。</p>]]></content>
    
    <summary type="html">
    
      深入理解JVM的垃圾回收机制GC！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TCP是如何保证传输可靠性的？</title>
    <link href="http://yoursite.com/2020/01/23/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/01/23/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F/</id>
    <published>2020-01-23T13:20:27.000Z</published>
    <updated>2020-01-23T15:36:09.383Z</updated>
    
    <content type="html"><![CDATA[<p>首先，要弄懂TCP是如何保证传输可靠的，就必须知道TCP的特点是什么，大家可以根据我的另一篇博客（TCP和UDP的区别）一起结合来看，更加容易明白。</p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p>20个字节包括源端口和目的端口，序号，确认号，数据偏移 <em>，</em>保留 ，窗口，检验和等等。</p><h4 id="保证方式："><a href="#保证方式：" class="headerlink" title="保证方式："></a>保证方式：</h4><p><strong>检验和</strong>：将发送数据都当做16位整数，相加，进位补在后面，最后取反。</p><p>发送与接收方都要进行检验和操作，不一致则代表数据传输有误，一致就表示数据不一定传输成功。</p><p><strong>确认号和序号</strong>：TCP三次握手建立连接，我们知道TCP传输每个字节都加了序号，每次接收方接收数据也都会返回发送方一个ACK报文，即确认报文，序号也可以排序，这些都可以保证传输可靠性。</p><p><strong>超时重传机制</strong>：发送数据后，迟迟等不到ACK确认报文，就开始重传机制也就是重新发送一遍。等不到ACK有俩种可能。一种是发送数据的时候就丢失了，接收方根本就没看见，另外一种是接收方收到数据了，发送了ACK报文但是丢失了或者超时，发送方接不到。</p><p><strong>流量控制：</strong>（针对点对点）我们知道TCP会根据接收窗口的窗口值来决定发送数据的大小，会进行拆分。所谓流量控制就是让发送方发送数据慢一些，不要让接收方压力太大，一口气接收不过来导致数据丢失。使用的方式就是滑动窗口！</p><p><strong>拥塞控制：</strong>（针对全局）防止过多的数据注入到网络中，这样可以使网络中的路由器或链路过载。解决方式：慢开始，拥塞避免，快重传，快恢复。</p>]]></content>
    
    <summary type="html">
    
      讲解TCP可靠传输是如何得到保障的
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>分布式-集群模式-微服务</title>
    <link href="http://yoursite.com/2020/01/22/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/01/22/%E5%88%86%E5%B8%83%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-01-22T07:53:23.000Z</published>
    <updated>2020-01-30T05:04:50.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>将一个大的系统划分为多个业务模块，业务模块分别部署到不同的机器上，各个业务模块之间通过接口进行数据交互，区别分布式的方式是根据不同机器不同业务。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群模式是不同服务器部署同一套服务对外访问，实现服务的负载均衡。一般配置Nginx的负载容器实现。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p> 微服务是一种面向服务的<strong>架构(SOA)风格</strong>，是很小的服务（松耦合），小到一个服务只对应一个单一的功能，只做一件事。这个服务可以单独部署运行，服务之间可以通过远程调用RPC（SpringCloud、Dubbo、Dubbox、Hessian、HttpClient、thrift等）来相互交互。说通俗点，就是将一个很小的方法写好，封装起来，专门让不同的人去调用。</p><p>微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。</p>]]></content>
    
    <summary type="html">
    
      分布式-集群模式-微服务的概念以及区分
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocl</title>
    <link href="http://yoursite.com/2020/01/21/ThreadLocl%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%81/"/>
    <id>http://yoursite.com/2020/01/21/ThreadLocl%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%81/</id>
    <published>2020-01-21T12:42:15.000Z</published>
    <updated>2020-01-21T13:09:10.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>用与之密切相关的俩个类来讲述ThreadLocal的工作原理：</p><p>分别是ThreadLocalMap，Thread。</p><p>其中ThreadLocalMap类的定义是在ThreadLocal类中，真正的引用却是在Thread类中。</p><p>ThreadLocalMap中用于存储数据的entry定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           /** The value associated with this ThreadLocal. */</span><br><span class="line">           Object value;</span><br><span class="line">           </span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>我们可以发现Map的key是ThreadLocal类的实例对象，value为用户的值。</p><p>所以根据上面可知，线程共享变量缓存如下：</p><p>线程共享变量缓存如下：</p><p><strong>Thread.ThreadLocalMap&lt;ThreadLocal, Object&gt;</strong></p><p>1、<strong>Thread: 当前线程，可以通过Thread.currentThread()获取。</strong></p><p>2、<strong>ThreadLocal：ThreadLocal实例对象。</strong></p><p>3、<strong>Object: 当前线程共享变量。</strong></p><p>ThreadLocal.get，ThreadLocal.set，ThreadLocal.remove方法都是从当前线程中获取ThreadLocalMap&lt;<strong>ThreadLocal, Object</strong>&gt;，然后获取或设置共享变量Object。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>每个线程独自拥有一个变量，并非是共享的（<strong>提供线程内的局部变量，这种变量在线程的生命周期内起作用</strong>）</p><p>final修饰的int型的threadLocalHashCode用来区分一个线程多个ThreadLocal对象</p><h3 id="内存泄漏问题（弱引用）："><a href="#内存泄漏问题（弱引用）：" class="headerlink" title="内存泄漏问题（弱引用）："></a>内存泄漏问题（弱引用）：</h3><p>当线程没有结束，但是ThreadLocal已经被回收，则可能导致线程中存在ThreadLocalMap&lt;<strong>null</strong>, <strong>Object</strong>&gt;的键值对，造成内存泄露。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量。</p><p>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</p>]]></content>
    
    <summary type="html">
    
      理解ThreadLocl的工作原理
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Sleep,和Wait!</title>
    <link href="http://yoursite.com/2020/01/19/Sleep%E5%92%8CWait/"/>
    <id>http://yoursite.com/2020/01/19/Sleep%E5%92%8CWait/</id>
    <published>2020-01-19T12:32:31.000Z</published>
    <updated>2020-01-30T12:47:15.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>继承自Thread类，无释放锁，会给低优先级线程运行的机会，必须捕获异常，让当前线程休眠指定时间，也可由interrupt()方法来唤醒，静态方法，任何地方可以使用，执行sleep()方法后转入阻塞状态。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h3><p>yield()方法只会给相同优先级或更高优先级的线程以运行的机会，无需捕获异常，执行yield()方法后转入就绪状态。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>继承自Object类，释放了锁（使得其他线程可以使用同步控制块或者方法），无需捕获异常，由notify,notifyAll方法唤醒，实例方法，只能在同步控制方法或者同步控制块里面使用。</p><h3 id="为什么wait只能在同步控制方法或者同步控制块里面使用？"><a href="#为什么wait只能在同步控制方法或者同步控制块里面使用？" class="headerlink" title="为什么wait只能在同步控制方法或者同步控制块里面使用？"></a>为什么wait只能在同步控制方法或者同步控制块里面使用？</h3><p>wait()暂停的是持有锁的对象，所以想调用wait()必须为:对象.wait();</p><p>因为要对持有锁的线程操作，所以要使用在同步中，因为只有同步才具有锁。</p><p><strong>锁可以是任意对象，所以任意对象调用的方法一定是定义在Object类中</strong></p>]]></content>
    
    <summary type="html">
    
      Sleep和Wait的区别，简显易懂
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nosql</title>
    <link href="http://yoursite.com/2020/01/19/redis%E5%92%8CMongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2020/01/19/redis%E5%92%8CMongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-01-19T02:25:01.000Z</published>
    <updated>2020-01-19T03:06:51.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB:"></a>MongoDB:</h2><p>概念：文档型数据库,类似json格式,它在许多场景下可用于<strong>替代</strong>统的关系型数据库或键/值存储方式。</p><p>特点：有权限验证类似RBAC，本身就是持久化数据库。</p><p>使用场景：主要解决海量数据的访问效率问题。比如网站的评论海量数据。</p><p>优点：</p><p>1.可处理大规模单表，容易分隔表。</p><p>2.非常高的插入速度。</p><p>3.高查询，支持二维空间索引，例如管道，快速定位。</p><p>缺点：</p><p>1.不支持事务（主要）</p><p>2.占用空间大</p><p>3.没有成熟维护工具</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><p>概念：开源的可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>特点：有权限验证，不过是全局的。Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。</p><p>使用场景：适用于对读写效率要求都很高，数据变化快等。例如：网站的点赞，计算，实时数据</p><p>支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><p>优点：</p><p>1.支持事务</p><p>2.数据存在内存，读写非常快</p><p>缺点：</p><p>由于 Redis 是内存数据库,所以,单台机器,存储的数据量,跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略,但是还是需要提前预估和节约内存</p><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase:"></a>HBase:</h2><p>概念：是 Apache Hadoop 中的一个子项目，实现语言java,HBase 依托于 Hadoop 的 HDFS（分布式文件系统）作为最基本存储基础单元。</p><p>特点：支持数十亿行X上百万列，不会出现单点故障，堪比MySQL的随机访问性能。</p><p>使用场景：</p><p>1.bigtable类型的数据存储</p><p>2.bigtable类型的数据存储</p><p>3.bigtable类型的数据存储</p><p>优点：</p><p>1.存储容量大，一个表可以容纳上亿行，上百万列</p><p>2.通过版本检索</p><p>3.可有效避免单点故障</p><p>缺点:</p><p>1.其API更适用于Java项目</p><p>2.占用空间大,依赖多，配置麻烦</p>]]></content>
    
    <summary type="html">
    
      NoSql型Redis和MongoDB和HBase的区别，优劣，使用场景
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别？</title>
    <link href="http://yoursite.com/2019/12/21/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/12/21/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2019-12-21T07:06:44.000Z</published>
    <updated>2020-01-22T05:56:07.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>1.TCP是<strong>面向连接</strong>的运输层协议。传送数据前需用三次握手方式进行连接，传送完毕后，必须释放已经建立的TCP连接。</p><p>2.TCP连接只能有俩个<strong>端点</strong>，即只能一对一，点对点。</p><p>3.TCP提供<strong>可靠支付</strong>的服务，无差错，不丢失，不重复，按序到达。</p><p>4.TCP提供<strong>全双工通信</strong>（通信双方都可作为传送者，接收者，且可以同时传输接收）</p><p>5.TCP面向<strong>字节流</strong>，流是指的是流入到进程或从进程流出的字节序列。</p><p>6.TCP不关心应用程序一次把多长的报文发送到TCP的缓存，而是根据对方给出的<strong>窗口值</strong>和当前<strong>网络拥塞</strong>的程度来决定一个报文段应包含多少个字节</p><p>7.首部20个字节（源端口和目的端口，序号，确认号，数据偏移 <em>，</em>保留 ）。</p><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>1.UDP是<strong>无连接</strong>的协议，传输数据前不需要建立连接，减小了开销和时延。</p><p>2.UDP连接支持一对一，一对多，多对一，多对多的交互通信。</p><p>3.UDP使用尽最大努力支付，即<strong>不可靠支付</strong>。</p><p>4.UDP<strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。</p><p>5.UDP<strong>面向报文</strong>，应用层交给UDP多长的报文，UDP就照样发送，既不合并，也不拆分，即一次发送一个报文</p><p>6.UDP发送的报文长度是应用进程给出的。</p><p>7.首部8个字节。</p>]]></content>
    
    <summary type="html">
    
      TCP和UDP哪里不同，具体表现在哪里？
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网关、路由、DNS、子网掩码、MAC地址的概念</title>
    <link href="http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/12/10/%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/</id>
    <published>2019-12-10T03:42:17.000Z</published>
    <updated>2019-12-10T04:17:17.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是网关"><a href="#1-什么是网关" class="headerlink" title="1.什么是网关"></a>1.什么是网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><p>大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。</p><p>按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。</p><p>那么网关到底是什么呢？网关实质上是一个<strong>网络</strong>通向<strong>其他网络</strong>的<strong>IP地址</strong>。</p><h3 id="2-ip地址又是什么"><a href="#2-ip地址又是什么" class="headerlink" title="2.ip地址又是什么"></a>2.ip地址又是什么</h3><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽<strong>物理地址</strong>的差异。</p><p>IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用”点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例如，192.168.1.1</p><p>常见的IP地址，分为IPv4与IPv6两大类。目前还有些ip代理软件，但大部分都收费。IPV4就是有4段数字，每一段最大不超过255。</p><h3 id="3-什么是物理地址"><a href="#3-什么是物理地址" class="headerlink" title="3.什么是物理地址"></a>3.什么是物理地址</h3><p>物理地址也就是我们常说的<strong>MAC地址</strong>，MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是<strong>唯一</strong>的。</p><p>mac地址位于OSI七层网络协议的第二层—<strong>数据链路层</strong>。通常表示为12个16进制数，每2个16进制数之间用冒号隔开，例如08:00:20:0A:8C:6D</p><h4 id="ip和mac区别"><a href="#ip和mac区别" class="headerlink" title="ip和mac区别"></a>ip和mac区别</h4><p>1.IP地址是服务商给你的，mac地址是你的网卡物理地址；</p><p>2.IP地址局域网内可以随便更改，但是mac地址一般不能更改；</p><p>3.长度不同。IP地址为32位，MAC地址为48位；</p><p>4.IP地址应用于OSI第三层，即网络层，而MAC地址应用在OSI第二层，即数据链路层。</p><p>5.总的来说，IP地址在网络中体现的是“<strong>我在哪里</strong>”，而mac地址则在二层通信中体现<strong>“我是谁”</strong></p><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h3><p>路由器是互联网络中必不可少的网络设备之一，路由器是一种连接多个网络或网段的网络设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读”懂对方的数据，从而构成一个更大的网络。</p><p>在<strong>没有路由器</strong>的情况下，不同的两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过<strong>网关</strong>。</p><h3 id="5-什么是DHS"><a href="#5-什么是DHS" class="headerlink" title="5.什么是DHS"></a><strong>5.什么是DHS</strong></h3><p>DNS：域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。</p><p>浏览器输入URL，例如<a href="http://www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。" target="_blank" rel="noopener">www.baidu.com，DNS服务器就自动帮我们解析这个域名并翻译成了IP地址61.135.169.105。</a></p><h3 id="6-子网掩码"><a href="#6-子网掩码" class="headerlink" title="6.子网掩码"></a>6.子网掩码</h3><p>子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。</p><p>那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><strong>举个例子</strong></h4><p> 有一个网段是192.168.1.0—–192.168.1.254，这个网段就像一个村子一样，就称它为<strong>安防村</strong>，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。</p><p>另外有一个网段，是192.168.0.0——192.168.255.254，我们叫它<strong>安村</strong>，村里有个同样有两个ip地址192.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？<br> 这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，<strong>安防村</strong>的网段是<strong>255.255.255.0</strong>，<strong>安村</strong>的网段是<strong>255.255.0.0</strong>。</p><p>网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。</p><p>强烈推荐一篇用故事讲解什么是网关，路由，dns的关系的文章，写的很好，大家可以看看奥</p><p>原文出处：<a href="https://blog.csdn.net/sgl520lxl/article/details/51974215" target="_blank" rel="noopener">https://blog.csdn.net/sgl520lxl/article/details/51974215</a></p>]]></content>
    
    <summary type="html">
    
      这篇主要讲述了几个关于计算机网络常见名词的解析
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>输入一个URL全过程！</title>
    <link href="http://yoursite.com/2019/12/08/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/"/>
    <id>http://yoursite.com/2019/12/08/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%81/</id>
    <published>2019-12-08T06:16:59.000Z</published>
    <updated>2020-01-31T13:42:48.891Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简单理解:</strong>  域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt;  服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）  –&gt; 浏览器对页面进行渲染呈现给用户。</p><p><strong>（1）域名解析（利用DNS）</strong></p><p>先校验输入的URL格式是否正确，默认都是http。</p><p>然后根据用户输入的网址去寻找它对应的IP地址，比如输入<a href="http://www.baidu.com它的ip地址为202.108.22.5" target="_blank" rel="noopener">www.baidu.com它的ip地址为202.108.22.5</a></p><p>一般会先去各种缓冲中查找，浏览器缓存，Hosts文件查找，路由器缓存，DNS缓存，都找不到就由DNS服务器查找。</p><p><strong>（2）建立TCP连接</strong> </p><p><strong>客户端发起请求：</strong></p><ol><li><p><strong>应用层</strong></p><p>DNS解析域名为目的IP，通过IP找到服务器路径，客户端向服务器发起HTTP会话，然后通过运输层TCP协议封装数据包，在TCP协议基础上进行传输。</p></li><li><p><strong>传输层</strong>，这里也就使用了<strong>TCP三次握手</strong></p><p>TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)，HTTP会话会被分成报文段，添加源、目的端口（默认80）；TCP协议进行主要工作。</p></li><li><p><strong>网络层</strong>是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址，利用ARP地址解析协议。</p></li><li><p>然后才是<strong>链路层</strong>将数据发送到数据链路层传输。至此请求报文已发出，客户端发送请求的阶段结束</p></li></ol><p><strong>服务端接受请求：</strong><br>原路进行处理：链路层—&gt;网络层—&gt;传输层—&gt;应用层然后响应客户端发送报文。</p><p><strong>（3）浏览器进行处理</strong></p><p>服务器通过后台语言程序处理,找到数据返回给浏览器,HTML字符串被浏览器接受后被一句句读取解析,解析到link标签后重新发送请求获取css,解析到sript标签后发送请求获取js,并执行代码</p><p><strong>（4）绘制网页</strong></p><p>然后浏览器会进行渲染，浏览器根据HTML和CSS计算得到渲染树,绘制到屏幕上,js会被执行</p>]]></content>
    
    <summary type="html">
    
      输入一个URL返回了一个页面的全过程解析！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK,JRE,JVM的关系</title>
    <link href="http://yoursite.com/2019/12/07/JDK-JRE-JVM%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/12/07/JDK-JRE-JVM%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2019-12-07T05:58:49.000Z</published>
    <updated>2019-12-07T06:07:04.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p><strong>JDK（Java Development Kit）</strong></p><p>Java开发工具包，Java标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。</p><p><strong>Java Runtime Environment（JRE）</strong></p><p>Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），只是针对于使用Java程序的用户。</p><p><strong>JVM（java virtual machine）</strong></p><p>就是我们常说的java虚拟机，它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。</p><p>也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p><h3 id="2-联系"><a href="#2-联系" class="headerlink" title="2.联系"></a>2.联系</h3><p>JDK是面向开发者的，JRE是面向使用JAVA程序的用户</p><p>JDK包括了Java运行环境JRE、Java工具和Java基础类库</p><p>JRE包含了JVM标准实现及Java核心类库。</p><p>JVM 是 java 编程语言的核心并且具有平台独立性。</p><p>JDK&gt;JRE&gt;JVM</p>]]></content>
    
    <summary type="html">
    
      JDK,JRE,JVM出现频率不可谓不多，那到底是什么，就让我们来看看
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>时间复杂度常见讲解</title>
    <link href="http://yoursite.com/2019/12/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E8%A7%81%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/12/04/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B8%B8%E8%A7%81%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-12-04T05:59:02.000Z</published>
    <updated>2019-12-04T06:27:44.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h2><p>O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话），<strong>冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域。</strong></p><p>例子：比如你面前有十个盒子，分别标着1-10号数字，你要找哪个数字直接就可以看到找出，不用一个一个都看一遍。那如果是N个盒子呢？同理，直接找你要的数字就可以了，所以耗时永远不变，为1.</p><h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。</p><p>例子：遍历算法，要找到一个数组里面最大的一个数，你需要把n个变量都扫描一遍，操作次数为n，那么算法复杂度就是O(n).</p><h2 id="O（n-2）"><a href="#O（n-2）" class="headerlink" title="O（n^2）"></a>O（n^2）</h2><p>时间复杂度O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比O(n)更高的时间复杂度</p><p>例子：冒泡排序，双重循环，用冒泡排序排一个数组，对于n个变量的数组，需要交换变量位置O(n^2)次，那么算法复杂度就是O(n^2)。</p><h2 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n)"></a>O(log n)</h2><p>O(log n)，当数据增大n倍时，耗时增大log n倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比O(n)还要低的时间复杂度）</p><p>例子：二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 </p><h2 id="O-n-log-n"><a href="#O-n-log-n" class="headerlink" title="O(n log n)"></a>O(n log n)</h2><p>O(n log n)同理，就是n乘以log n，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于O(n)低于O(n^2)。</p><p>例子：归并排序，两个顺序序列合并成一个顺序序列，就是O(n log n)的时间复杂度。</p><p>原文地址：<a href="https://blog.csdn.net/lkp1603645756/article/details/85013126" target="_blank" rel="noopener">https://blog.csdn.net/lkp1603645756/article/details/85013126</a></p>]]></content>
    
    <summary type="html">
    
      这篇讲解O(1)、O(n)、O(n^2)、O(log n)、O(n log n)到底是个什么意思
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>可爱又易懂的贪心算法</title>
    <link href="http://yoursite.com/2019/12/04/%E5%8F%AF%E7%88%B1%E5%8F%88%E6%98%93%E6%87%82%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/04/%E5%8F%AF%E7%88%B1%E5%8F%88%E6%98%93%E6%87%82%E7%9A%84%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2019-12-04T05:53:22.000Z</published>
    <updated>2019-12-04T05:56:52.844Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不看后悔啊！"><a href="#不看后悔啊！" class="headerlink" title="不看后悔啊！"></a>不看后悔啊！</h4><p>源文地址：<a href="http://baijiahao.baidu.com/s?id=1642122740570394361&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1642122740570394361&amp;wfr=spider&amp;for=pc</a></p>]]></content>
    
    <summary type="html">
    
      今天本人在学贪心算法的时候，看到了一篇非常有意思的文章，一定要推荐给大家，既开心了，又学到东西了。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://yoursite.com/2019/12/03/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/12/03/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-12-03T10:50:01.000Z</published>
    <updated>2020-01-31T14:01:57.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-保证内存可见性"><a href="#1-保证内存可见性" class="headerlink" title="1. 保证内存可见性"></a>1. 保证内存可见性</h2><p>​        所有线程的共享变量都存储在主内存中，每一个线程都有一个独有的工作内存，每个线程不直接操作在主内存中的变量，而是将主内存上变量的副本放进自己的工作内存中，只操作工作内存中的数据。当修改完毕后，再把修改后的结果放回到主内存中。每个线程都只操作自己工作内存中的变量，无法直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p><p>​        单线程环境下不会出现问题，而多线程会出现问题，会出现脏数据。</p><p>​        而volatile关键字可以使当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。所以说保证了内存可见性。</p><h2 id="2-禁止指令重排序"><a href="#2-禁止指令重排序" class="headerlink" title="2. 禁止指令重排序"></a>2. 禁止指令重排序</h2><p>​        指令的执行顺序并不一定会像我们编写的顺序那样执行，为了保证执行上的效率，JVM可能会对指令进行重排序。</p><p>​        而volatile关键字可以禁止指令重排序，即程序执行的顺序按照代码的先后顺序执行。</p><h2 id="3-不保证原子性"><a href="#3-不保证原子性" class="headerlink" title="3.不保证原子性"></a>3.不保证原子性</h2><p>​        也就是说，对volatile修饰的变量进行的操作，不保证多线程安全。</p><h2 id="4-单例模式的双重锁为什么要加volatile？"><a href="#4-单例模式的双重锁为什么要加volatile？" class="headerlink" title="4.单例模式的双重锁为什么要加volatile？"></a>4.单例模式的双重锁为什么要加volatile？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line"> instance =<span class="keyword">new</span> Singleton();   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第5行会出现问题。instance = new TestInstance();可以分解为3行伪代码</p><p>a.为instance分配内存</p><p>b.初始化instance</p><p>c.将instance变量指向分配的内存空间</p><p>上面的代码在编译运行时，可能会出现重排序从a-b-c排序为a-c-b。在多线程的情况下会出现以下问题。当线程A在执行第5行代码时，B线程进来执行到第2行代码。假设此时A执行的过程中发生了指令重排序，即先执行了a和c，没有执行b。那么由于A线程执行了c导致instance指向了一段地址，所以B线程判断instance不为null，会直接跳到第6行并返回一个未初始化的对象。</p><h3 id="CAS（无锁化机制）"><a href="#CAS（无锁化机制）" class="headerlink" title="CAS（无锁化机制）:"></a>CAS（无锁化机制）:</h3><p>实现多线程同步的原子指令！</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。缺点，解决不了ABA问题和多线程下无限自旋问题。</p><p>ABA：线程1对值为A的value正在进行操作，但是，线程2这时进来，将value改为B，并在线程1结束之前，又将value改为了A。此时线程1再进CAS操作的时候，A值虽然不变，但已经不是同一个值了。</p><p>如何解决：Java 8有一个新的类，LongAdder，就是将value值分离成一个数组，当多线程访问时，通过hash算法映射到其中的一个数字进行计数。而最终的结果，就是这些数组的求和累加。这样一来，就减小了锁的粒度</p>]]></content>
    
    <summary type="html">
    
      很常见的volatile关键字的作用
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java的反射到底是个啥？</title>
    <link href="http://yoursite.com/2019/11/30/java%E7%9A%84%E5%8F%8D%E5%B0%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/30/java%E7%9A%84%E5%8F%8D%E5%B0%84%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</id>
    <published>2019-11-30T05:49:55.000Z</published>
    <updated>2019-11-30T06:05:36.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请说明一下JAVA中反射的实现过程和作用分别是什么？"><a href="#请说明一下JAVA中反射的实现过程和作用分别是什么？" class="headerlink" title="请说明一下JAVA中反射的实现过程和作用分别是什么？"></a>请说明一下JAVA中反射的实现过程和作用分别是什么？</h2><p> JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：<strong>Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</strong> </p><p> 作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。 </p><h2 id="什么是反射-？"><a href="#什么是反射-？" class="headerlink" title="什么是反射 ？"></a><strong>什么是反射</strong> ？</h2><p> 反射就是把java类中的各种成分映射成一个个的Java对象 </p><p> 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 </p><h2 id="反射相关类常见的方法"><a href="#反射相关类常见的方法" class="headerlink" title="反射相关类常见的方法"></a><strong>反射相关类常见的方法</strong></h2><ul><li><strong>获得类相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>asSubclass(Class<U> clazz)</U></td><td>把传递的类的对象转换成代表其子类的对象</td></tr><tr><td>Cast</td><td>把对象转换成代表类或是接口的对象</td></tr><tr><td>getClassLoader()</td><td>获得类的加载器</td></tr><tr><td>getClasses()</td><td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td></tr><tr><td>getDeclaredClasses()</td><td>返回一个数组，数组中包含该类中所有类和接口类的对象</td></tr><tr><td>forName(String className)</td><td>根据类名返回类的对象</td></tr><tr><td>getName()</td><td>获得类的完整路径名字</td></tr><tr><td>newInstance()</td><td>创建类的实例</td></tr><tr><td>getPackage()</td><td>获得类的包</td></tr><tr><td>getSimpleName()</td><td>获得类的名字</td></tr><tr><td>getSuperclass()</td><td>获得当前类继承的父类的名字</td></tr><tr><td>getInterfaces()</td><td>获得当前类实现的类或是接口</td></tr></tbody></table><ul><li><strong>获得类中属性相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getField(String name)</td><td>获得某个公有的属性对象</td></tr><tr><td>getFields()</td><td>获得所有公有的属性对象</td></tr><tr><td>getDeclaredField(String name)</td><td>获得某个属性对象</td></tr><tr><td>getDeclaredFields()</td><td>获得所有属性对象</td></tr></tbody></table><ul><li><strong>获得类中注解相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getAnnotation(Class<A> annotationClass)</A></td><td>返回该类中与参数类型匹配的公有注解对象</td></tr><tr><td>getAnnotations()</td><td>返回该类所有的公有注解对象</td></tr><tr><td>getDeclaredAnnotation(Class<A> annotationClass)</A></td><td>返回该类中与参数类型匹配的所有注解对象</td></tr><tr><td>getDeclaredAnnotations()</td><td>返回该类所有的注解对象</td></tr></tbody></table><ul><li><strong>获得类中构造器相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getConstructor(Class…&lt;?&gt; parameterTypes)</td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td>getConstructors()</td><td>获得该类的所有公有构造方法</td></tr><tr><td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td>getDeclaredConstructors()</td><td>获得该类所有构造方法</td></tr></tbody></table><ul><li><strong>获得类中方法相关的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td>获得该类某个公有的方法</td></tr><tr><td>getMethods()</td><td>获得该类所有公有的方法</td></tr><tr><td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td><td>获得该类某个方法</td></tr><tr><td>getDeclaredMethods()</td><td>获得该类所有方法</td></tr></tbody></table><ul><li><strong>类中其他重要的方法</strong></li></ul><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>isAnnotation()</td><td>如果是注解类型则返回true</td></tr><tr><td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td><td>如果是指定类型注解类型则返回true</td></tr><tr><td>isAnonymousClass()</td><td>如果是匿名类则返回true</td></tr><tr><td>isArray()</td><td>如果是一个数组类则返回true</td></tr><tr><td>isEnum()</td><td>如果是枚举类则返回true</td></tr><tr><td>isInstance(Object obj)</td><td>如果obj是该类的实例则返回true</td></tr><tr><td>isInterface()</td><td>如果是接口类则返回true</td></tr><tr><td>isLocalClass()</td><td>如果是局部类则返回true</td></tr><tr><td>isMemberClass()</td><td>如果是内部类则返回true</td></tr></tbody></table><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>equals(Object obj)</td><td>属性与obj相等则返回true</td></tr><tr><td>get(Object obj)</td><td>获得obj中对应的属性值</td></tr><tr><td>set(Object obj, Object value)</td><td>设置obj中对应属性值</td></tr></tbody></table><h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>invoke(Object obj, Object… args)</td><td>传递object对象及参数调用该对象对应的方法</td></tr></tbody></table><h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>newInstance(Object… initargs)</td><td>根据传递的参数创建类的对象</td></tr></tbody></table><p>以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。</p><p>getMethod(parameterTypes)用来获取某个公有的方法的对象，</p><p>getMethods()获得该类所有公有的方法，</p><p>getDeclaredMethod(parameterTypes)获得该类某个方法，</p><p>getDeclaredMethods()获得该类所有方法。</p><p><strong>带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。</strong></p><p>其他的Annotation、Field、Constructor也是如此。</p>]]></content>
    
    <summary type="html">
    
      通俗易懂的理解java反射！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>rest?restful?到底是什么？</title>
    <link href="http://yoursite.com/2019/11/27/rest-restful-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/11/27/rest-restful-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2019-11-27T11:12:07.000Z</published>
    <updated>2020-01-23T16:11:21.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-关于Rest"><a href="#1-关于Rest" class="headerlink" title="1.关于Rest"></a>1.关于Rest</h2><p>rest  :representational state transfer    表述性状态转移,是一种架构风格。</p><p>技术实现：输入ajax请求，输出json数据。</p><p>rest具体表现：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p><h2 id="2-关于Restful"><a href="#2-关于Restful" class="headerlink" title="2.关于Restful"></a>2.关于Restful</h2><p>restful: 遵守了rest 原则 的web服务</p><p>理解：rest与restful相比，多了一个ful,就英语层面来说是一个形容词，restful翻译为中文为： “rest式的”</p><p>是rest式的什么呢？答案是 rest式的应用。</p><h2 id="3-两者的联系与区别"><a href="#3-两者的联系与区别" class="headerlink" title="3.两者的联系与区别"></a>3.两者的联系与区别</h2><p>restful是由rest派生出来的。</p><p>二.restful用法：</p><p>在Restful之前的操作：<br><a href="http://127.0.0.1/user/query/1" target="_blank" rel="noopener">http://127.0.0.1/user/query/1</a> GET  根据用户id查询用户数据<br><a href="http://127.0.0.1/user/save" target="_blank" rel="noopener">http://127.0.0.1/user/save</a> POST 新增用户<br><a href="http://127.0.0.1/user/update" target="_blank" rel="noopener">http://127.0.0.1/user/update</a> POST 修改用户信息<br><a href="http://127.0.0.1/user/delete" target="_blank" rel="noopener">http://127.0.0.1/user/delete</a> GET/POST 删除用户信息</p><p>RESTful用法：<br><a href="http://127.0.0.1/user/1" target="_blank" rel="noopener">http://127.0.0.1/user/1</a> GET  根据用户id查询用户数据<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  POST 新增用户<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  PUT 修改用户信息<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a>  DELETE 删除用户信息</p><p>在之前的操作，你每次请求的接口或者地址,都在做描述,例如查询的时候用了query,新增的时候用了save,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求，也就是说用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p><p>我个人感觉，Restful之前的风格也是挺好的，毕竟直观，也可以完成需求，看每个人的用法了，是规范不是必须嘛。</p>]]></content>
    
    <summary type="html">
    
      老听到Restful风格很有名，不知道什么东西，这篇就讲讲Restful到底是什么。
    
    </summary>
    
    
    
  </entry>
  
</feed>
