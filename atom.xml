<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HF Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-22T12:07:55.957Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HF</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>final关键字</title>
    <link href="http://yoursite.com/2019/11/22/final/"/>
    <id>http://yoursite.com/2019/11/22/final/</id>
    <published>2019-11-22T12:03:39.000Z</published>
    <updated>2019-11-22T12:07:55.957Z</updated>
    
    <content type="html"><![CDATA[<p>  final修饰的方法，不允许被子类覆盖。 </p><p>  final修饰的类，不能被继承。 </p><p>  final修饰的变量，不能改变值。 </p><p>  final修饰的引用类型，不能再指向别的东西，但是可以改变其中的内容。 </p><p> final修饰的成员变量在赋值时可以有三种方式。1、在声明时直接赋值。2、在构造器中赋值。3、在初始代码块中进行赋值。  </p><p> 对于static final修饰的变量，其定义可以有两处。1、变量申明处，2、静态构造代码块。 </p><p> static  final和final之间的区别是，前者代表对于一个类恒定不变的属性，后者代表对于一个类来说恒定不变的属性，但是对于同一个类不同对象之间还是可以变换的。 </p>]]></content>
    
    <summary type="html">
    
      final关键字的用法以及特性
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HashMap的底层原理</title>
    <link href="http://yoursite.com/2019/11/22/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/22/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2019-11-22T07:15:02.000Z</published>
    <updated>2019-11-23T03:39:47.179Z</updated>
    
    <content type="html"><![CDATA[<p><strong>①HashMap的工作原理</strong></p><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p><p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p><p> HashMap的好处非常多，我们会经常用到HashMap和ConcurrentHashMap。 </p><p>HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口。</p><p>HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；由于它的键可以是为空的，所以，所以我们不能用get（key）判断是否有这个键，而应该用containsKey（）这个方法来判断是否有这个键；</p><p>HashMap数据结构的优点    1.适合海量数据   2.o(1)的随机访问速度，不是可遍历。</p><p> HashMap默认容量为16，且要求容量一定为2的整数次幂。 </p><h3 id="②HashMap和Hashtable的区别"><a href="#②HashMap和Hashtable的区别" class="headerlink" title="②HashMap和Hashtable的区别"></a><strong>②HashMap和Hashtable的区别</strong></h3><p> HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度 </p><p>1.HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p>2.HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 </p><p>3.由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 </p><p>4.HashMap不能保证随着时间的推移Map中的元素次序是不变的。 </p><p>5.HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap); </p><p>6.Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</p><h3 id="③HashMap和HashSet的区别"><a href="#③HashMap和HashSet的区别" class="headerlink" title="③HashMap和HashSet的区别"></a>③HashMap和HashSet的区别</h3><p> 1.HashMap实现了Map接口 ,HashSet实现了Set接口 </p><p> 2.HashMap储存键值对 ,HashSet仅仅存储对象 </p><p>3.HashSet仅仅存储对象 , ,HashSet使用add()方法将元素放入set中 </p><p>4.HashMap中使用键对象来计算hashcode值 , HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false </p><p>5.HashSet较HashMap来说比较慢 </p><h3 id="④CurrentHashMap和HashMap的区别"><a href="#④CurrentHashMap和HashMap的区别" class="headerlink" title="④CurrentHashMap和HashMap的区别"></a>④CurrentHashMap和HashMap的区别</h3><p>在jdk1.5的时候就出来了CurrentHashMap来弥补HashMap的线程不安全的特性；CurrentHashMap，是将HashMap分成了很多个片（一般默认是16片），引入了分段锁的概念，然后对每一片加锁，具体可以理解成一把大的Map分解成N个小的HashTable，根据key.hashCode()来决定放到哪一个片上；</p><p>由于安全机制的原因，HashMap的效率比HashTable，CurrentHashMap的效率高；但是由于CurrentHashMap加锁的高效性,HashTable是整个加锁，他的效率比HashTable高； 总的来说 <strong>HashMap&gt;CurrentHashMap&gt;HashTable;</strong></p><p>CurrentHashMap的问题还得单独拿出来说一下，东西挺多的，等我在另外一篇博客总结一下吧。</p><p><strong>最重要的来了，面试题！</strong></p><p> 1.“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 答案如下:</p><p> HashMap是基于hashing的原理，我们使用put(key,  value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。 </p><p> 2.下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： </p><p> “当两个对象的hashcode相同会发生什么？”      因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。 </p><p> “如果两个键的hashcode相同，你如何获取值对象？”    当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置 ,找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！  </p><p>3.’’如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办?’’ :</p><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 </p><p>4.“你了解重新调整HashMap大小存在什么问题吗？” </p><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail  traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？ </p><p>5.为什么String, Interger这样的wrapper类适合作为键？ </p><p>一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 </p><p> 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 </p><p> 6.我们可以使用CocurrentHashMap来代替Hashtable吗？</p><p>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性 </p><p>这已经是非常全的内容和面经了，东西虽然多，但是非常重要，希望我自己也能滚瓜乱熟！</p><p>借鉴文章地址：<a href="https://blog.csdn.net/suifeng629/article/details/82179996" target="_blank" rel="noopener">https://blog.csdn.net/suifeng629/article/details/82179996</a></p>]]></content>
    
    <summary type="html">
    
      HashMap的原理以及和HashTable，CurrentHashMap，TreeMap的区别，程序员新手老生常谈的问题，必看！通俗易懂，而且全，有面试的更加推荐奥！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://yoursite.com/2019/11/22/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/11/22/%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2019-11-22T07:00:47.000Z</published>
    <updated>2019-11-22T07:07:48.101Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/.com//C:%5CUsers%5Cqq%5CDesktop%5Cprogram%5CHexoBlog%5Csource_posts%5C%E5%86%85%E9%83%A8%E7%B1%BB%5C%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="内部类"></p>]]></content>
    
    <summary type="html">
    
      内部类大全，拿走不谢！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>javac和java的区别</title>
    <link href="http://yoursite.com/2019/11/22/javac%E5%92%8Cjava%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/22/javac%E5%92%8Cjava%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-11-22T06:44:47.000Z</published>
    <updated>2019-11-22T06:45:26.145Z</updated>
    
    <content type="html"><![CDATA[<p>cmd中，执行java命令与javac命令的区别：</p><p><strong>javac</strong>：是编译命令，将java源文件编译成.class字节码文件。</p><p>例如：<strong>javac hello.java</strong></p><p>将生成<strong>hello.class</strong>文件。</p><p><strong>java</strong>：是运行字节码文件；由java虚拟机对字节码进行解释和运行。</p><p>例如：<strong>java hello</strong>（相当于运行.exe文件）</p>]]></content>
    
    <summary type="html">
    
      简述javac和java命令
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Interger方法</title>
    <link href="http://yoursite.com/2019/11/22/Interger%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/22/Interger%E6%96%B9%E6%B3%95/</id>
    <published>2019-11-22T06:43:28.000Z</published>
    <updated>2019-11-22T06:44:21.544Z</updated>
    
    <content type="html"><![CDATA[<p>  Integer.parseInt(“”);是将字符串类型转换为int的基础数据类型 </p><p>  Integer.valueOf(“”)是将字符串类型数据转换为Integer对象 </p><p>  Integer.intValue();是将Integer对象中的数据取出，返回一个基础数据类型int </p><p>牛客的一道例题：</p><p>  a = Integer.parseInt(“1024”);  </p><p>  b = Integer.valueOf(“1024”).intValue();     </p><p>小伙伴认为是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a和b都是整数类型变量并且它们的值相等</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Interger包装类常用方法，面试用奥
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面向对象5大基本原则</title>
    <link href="http://yoursite.com/2019/11/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/11/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2019-11-22T06:42:11.000Z</published>
    <updated>2019-11-22T06:43:01.971Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>单一职责原则（SRP）</strong>：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。<br> <strong>开放封闭原则（OCP）</strong>：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。<br> <strong>Liskov替换原则（LSP）</strong>：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。<br> <strong>依赖倒置原则（DIP）</strong>：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。<br> <strong>接口隔离原则（ISP）</strong>：使用多个小的专门的接口，而不要使用一个大的总接口 。</p><p>很多同学或者新手学了java也挺长时间了，但五大基本原则有的还都没有听说过，最近在牛客网刷题，既然考出来了就给大家放上去吧。看看，嘻嘻！</p>]]></content>
    
    <summary type="html">
    
      java面向对象
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>远程数据库导入本地</title>
    <link href="http://yoursite.com/2019/11/21/%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/"/>
    <id>http://yoursite.com/2019/11/21/%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0/</id>
    <published>2019-11-21T04:20:56.000Z</published>
    <updated>2019-11-22T05:14:09.987Z</updated>
    
    <content type="html"><![CDATA[<p>本人在刚上大三的时候，和同学接了一个小项目，是一个老师的监督管理系统，也是第一次有稍稍多的数据量（小声哔哔，对我这种菜鸟已经算多了)几千条左右。那时，朋友将数据全部都导入到了他的MySql中，并修改了部分，我去和他要，他让我自己导入进去，没办法只能上网搜索，没想到还挺简单。这次，记录下来也是为了让自己记住，下次可以一起性搞定！</p><p>一.Ctrl+R 打开CMD</p><p>二.输入                                                                                                                                                    <strong>mysqldump -h 111.111.111.111  -uROSE -pPASSWORD  –port  3306   –opt   –compress  sdbname</strong>  </p><p><strong>–skip-lock-tables |  mysql -h  localhost  -uroot -proot  dbname</strong></p><p>三.<font color="red">注意事项</font>(千万注意，我就是弄混了，输错了好几遍！)</p><p><strong>111.111.111.111</strong> 远程服务器ip </p><p><strong>ROSE</strong> 远程数据库用户名</p><p><strong>PASSWORD</strong> 远程数据库用户密码</p><p><strong>3306</strong> 远程数据库使用的端口</p><p><strong>sdbname</strong> 要导入的源数据库名</p><p><strong>dbname</strong> 要导入的目的数据库名</p><p>转载地址： <a href="https://blog.csdn.net/gj591851/article/details/45287953" target="_blank" rel="noopener">https://blog.csdn.net/gj591851/article/details/45287953</a> </p>]]></content>
    
    <summary type="html">
    
      这篇讲解如何将远程数据库导入本地数据库
    
    </summary>
    
    
    
  </entry>
  
</feed>
